# 테스트 조직
## AAA 로 테스트 일관성 유지
- Arange : 준비 
- Act : 실행 
- Assert : 단언

## 동작 테스트 vs 메서드 테스트
- 클래스 동작에 집중해야하며 개별 메서드를 테스트한다고 생각하면 안된다. 
- 메서드는 객체의 필드만 리턴하므로 의미가 없다. 입금과 출금같은 다른 동작이 먼저 나와야한다.

## 내부 데이터 노출 vs 내부 동작 노출
- 내부 세부 사항을 테스트하는 것은 저품질로 이루어질 수 있다. 
- 하지만 근본적으로 내부 행위를 테스트해야한다면 설계에 문제가 있는 것이다.

## 테스트를 분리하면
- 단언이 실패했을때 실패한 테스트 이름이 표시되기 때문에 어느 동작에서 문제가 있는지 빠르게 파악할 수 있다. 
- 실패한 테스트를 해독하는데 필요한 시간을 줄일 수 있다. JUnit 은 각 테스트를 별도의 인스턴스로 실행하기 떄문에 현재 실패한 테스트에 대해 다른 테스트의 영향을 제거할 수 있다.
- 모든 케이스가 실행되었음을 보장할 수 있다. 단언 실패는 java.lang.AssertsionError를 던지기 때문이다. 단언이 실패하면 현재 테스트 메서드는 중단한다. 단언 실패 이후의 테스트 케이스는 실행되지 않는다.

## 문서로서의 테스트
- doingSomeOperationGeneratesSomeResult : 어떤 동작을 하면 어떤 결과가 나온다.
- someResultOccursUnderSomeCondition : 어떤 결과는 어떤 조건에서 발생한다.
- givenSomeContextWhenDoingSomeBehaviorThenSomeResultOccurs : 주어진 조건에서 어떤 일을 하면 어떤 결과가 나온다.
- whenDoingSomeBehaviorThenSomeResultOccurs : 어떤 일을 하면 어떤 결과가 나온다.

## @BeforeEach
다수의 BeforeEach 가 있을때 JUnit 은 순서를 보장하지 않는다. 일정한 순서가 필요하다면 단일 메서드로 결합하여 순서대로 실행되도록 해야한다.

## @Disable
문제가 있는 테스트를 주석 처리 하기 보다 @Disable 어노테이션을 활용하자.


# 좋은 테스트의 속성
### F : fast
- 테스트 코드는 빠르게 동작해야한다.
- 느린 것에 의존하는 코드를 최소화 하고 코드를 객체 지향 설계 개념과 맞출수록 단위 테스트 작성도 쉬워진다.

### I : Isolate
- 좋은 단위 테스트는 다른 단위 테스트에 의존하지 않는다.
- 어떤 순서나 시간에 관계없이 수행되어야한다. 
- 검증하려는 작은 양의 코드에 집중한다. 
- 클래스는 작고 단일한 목적을 가져야 한다(클래스를 변경해야할 이유가 하나만 있어야한다.) 테스트 메서드가 하나 이상의 이유로 깨진다면 테스트를 분할하는 것도 고려해보자.

### R : Repeatable
- 예를들어 현재 시간을 다루어야한다면 반복 가능한 테스트를 힘들게 하는 불편한 요소를 다루게 된다.
- 타임스탬프는 움직이는 표적이므로 특정 타임스탬프를 Clock 객체를 통해서 다뤄 반복 가능하게 할 수 있다.

### S : Self-validating
- 테스트는 스스로 검증 가능할 뿐 아니라 준비할 수도있어야한다.
- 테스트에 필요한 설정 단계는 자동화 해야한다. 
- Infinitest 같은 도구를 사용할 수도 있다.

### T : Timely
- 단위 테스트를 미루지 말고 반드시 테스트 코드를 작성하자.
- 코드에 큰 결함이 없고 당장 변경할 예정이 없다면 옛날 코드에 대한 테스트는 시간 낭비가 될 수 있다.

## Right-BICEP : 무엇을 테스트할 것인가?

### Right : 결과가 올바른가?
행복 경로 테스트를 테스트 할 수 있다면 그부분의 코드에 대해 이해한 것이다.
단위 테스트는 선택을 문서한다. 어떤 변경이 발생하면 적어도 현재까지 코드가 어떻게 동작했는지는 알게 된다.

## B : boundary 경계조건은 맞는가?
행복 경로는 입력 값의 양극단을 다루는 코드 시나리오의 경계 조건에 걸리지 않을 수도 있다. 결함은 주로 모서리 사례에서 발생하므로 테스트로 이것을 처리해야한다. 모서리 사례란 비거나 빠진 값, 이성적인 기댓값을 훨씬 벗어나는 값, 중복을 허용해서는 안 되는 목록에 중복 값이 있는 경우와 같은 것이 있다.

### 경계 조건에서는 CORRECT 를 기억하자
테스트는 경계 조건을 잘 알아둬야 고품질의 테스트 코드를 작성할 수 있다.
- C: conformance (준수) 값이 기대한 양식을 준수하고 있는가?
  - 기대하는 구조에 입력 데이터가 맞는지 확인해봐야한다.
  - 계좌 번호 같은 필드는 시스템에 있는 메서드에 넘겨진다 하지만 시스템에 그 필드가 처음 입력될때 검증되면 인자로 넘길때마다 검사하지 않아도된다.
  - 시스템 의 데이터 흐름을 이해해서 불필요한 검사는 최소화 하자
- O: ordering (순서) 값의 집합이 적절하게 정렬되거나 정렬되지 않았나? 
  - 데이터 순서 조건을 확인
- R: Range(범위) 이성적인 최솟값과 최댓값 안에 있는가?
  - 시스템에서 범위에 관한 제약을 만들자
  - @After, TypeSafeMatcher 를 확장해 불변성을 검사하는 사용자 정의 매처를 생성해서 검사할 수 있다.
- R: Reference(참조) 코드 자체에서 통제할 수 없는 어떤 외부 참조를 포함하고 있는가?
  - 범위를 넘어서는 것을 참조하고 있지 않은지
  - 외부 의존성은 무엇인지
  - 특정 상태에 있는 객체를 의존하고 있는지
  - 반드시 존재해야하는 다른 조건들
  - 이런 조건들이 맞지 않을때 코드가 잘 동작하는지 테스트해야한다.
- E: Existence(존재) 값이 존재하는가? 
  - null, 0 을 받았을때 어떤 일이 일어나는지 확인하는 테스트에 대한 작성
- C : Cardinality 기수 정확히 충분한 값들이 있는가?
  - 목록에 항목이 하나도 없을때
  - 목록에 항목이 한 개만 있을때
  - 목록에 항목이 한나만 있을 때
  - 목록에 항목이 요구하는 사이즈 미만일때
  - 이런 개수를 어떻게 잘 세어 테스트할지 고민해보고 얼마나 많은지 확인해봐야한다.
- T: Time(시간) 모든 것이 순서대로 정확한 정시에 일어나는가?
  - 상대적 시간(시간 순서)
  - 절대적 시간(측정된 시간)
  - 동시성 문제들
  - login() 은 logout()보다 먼저 호출되어야한다.
  - 수명이 짧은 자원에 대해 코드가 얼마나 기다릴 수 있는지 결정해야한다.
  - 클라이언트에 동시성 요구 사항이 있다면 다수의 클라이언트 스레드를 보여주는 테스트를 작성할 필요가 있다.


## I : inverse relationship 역 관계를 검사할 수 있는가?
- 때때로 논리적인 역 관계를 적용하여 행동을 검사할 수 있다. 종종 수학 계산에서 사용한다. 제곱근 로직의 도치는 곱셈인것과 같은때 사용한다.
- 응답이 긍정인 예를 찾는 것도 구현할 수 있지만 교차 검사는 모든 요소를 더하고 균형이 맞는지 확인하는 방법으로 긍정과 부정 답변을 전부 합하면 전체가 된다는 명제도 맞아야한다.

## C : Cross-check 다른 수단을 활용하여 교차 검사할 수 있는가?
- 도서 대출 시스템을 개발한다고 했을때 대출된 도서와 선반의 도서를 모두 합하면 각 도서의 총수량과 같아야한다.
- 각 도서는 서로 다른 장소에 저장될 수 있지만 모두 합하면 합이 맞아야한다.
- 교차 검사는 다른 클래스의 서로 다른 조각 데이터를 사용하여 모든 데이터가 합산되는지 확인해 보는 방법이 있다.

## E : Error conditions 오류 조건을 강제로 일어나게 할 수 있는가?
- 테스트 코드도 오류를 강제로 발생시켜야한다.
- 특정 네트워크 오류를 시뮬레이션 하려면 특별한 기법이 필요하다.
- 코드를 테스트하기 위해 도입할 수 있는 오류의 종류 또는 다른 환경적인 제약도 생각해보자
  - 메모리가 가득 찰 때
  - 디스크 공간이 가득 찰 때
  - 클라와 서버간 시간이 달라서 생기는 문제
  - 네트워크 가용성 및 오류들 
  - 시스템 로드
  - 제한된 색상 팔레트
  - 매우 높거나 낮은 비디오 해상도
- 좋은 단위 테스트는 로직 전체에 대한 커버리지를 달성하는 것이 아니라 예상치 못한 결함들에 대해 창의력을 발휘하여 작성하는 것이다.

## P : Performance characteristics 성능조건은 기준에 부합하는가?
- 성능 문제를 추측으로 대응하기 보다는 단위 테스트를 설계하여 진짜 문제가 어디에 있으며 예상한 변경 사항으로 어떤 차이가 생겼는지 파악해야한다.
- 코드 덩어리를 충분한 횟수만큼 실행시켜 타이밍과 CPU 클록 주기에 대한 이슈를 제거한다.
- 반복하는 코드 부분을 자바가 최적화 하지 못하는지 확인해야한다.
- 최적화되지 않은 테스트는 매우 느리다. 느린 테스트는 빠른 것과 분리한다.
- 동일한 머신이라도 실행시간은 시스템 로드처럼 잡다한 요소에 따라 달라질 수 있다.
- 단위 성능 측정을 잘 하기 위해서는 변경 사항을 만들 때 기준점을 활용하는 것이다.
- 성능이 향상되는지 확인하기 위해 최적화 하기 전 기준점으로 현재 경과시간을 측정하는 성능 테스트를 작성하고 평균 계산 후 코드 변경후 다시 실행해 결과를 비교하자.

# refactoring
- 성능이 즉시 문제 되지 않는다면 어설픈 최적화 노력 보다는 코드를 깔끔하게 유지하자.
- 최적화된 코드는 일반적으로 코드 가독성이 낮고 유지 보수 비용이 증가하고 설계가 유연하지 않다.
- 깔끔한 설계는 성능을 위해 최적화할 때 즉시 대응할 수 있는 최선의 보호막이다.
- 깔끔한 설계는 코드를 이동시킬 수 있는 유연성을 제공하고 다른 알고리즘을 적용하는 데도 수월하다.

## SRP
- 클래스의 책임은 하나여야하고 이는 클래스를 변경할 때는 단 한 가지 이유만 있어야 한다.
- 클래스에 더 많은 책임이 존재할수록 클래스에 있는 코드를 변경할 때 기존의 다른 동작들을 깨기 쉽다.
- 작고 집중화된 클래스는 다른 맥락에서도 재활용이라는 가치를 제공할 수 있다.
- 반면 다수의 책임을 가진 큰 클래스는 다른 맥락에서 사용되기 어렵다.

## 단위 테스트의 유지 보수 비용
- 시스템 코드 품질이 낮을 수록 단위 테스트의 유지 보수 비용은 증가한다.
- private 메서드를 테스트하는 것은 클래스가 필요 이상으로 커졌다는 의미이다.
- 코드 중복은 테스트를 따르기가 어려워진다.
- 작은 코드 조각을 단일 메서드로 추출하면 코드 조각 변경시 미치는 영향을 최소화 할 수 있다.

# 목 객체 사용
## 번거로운 동작을 스텁으로 대체
- 테스트 용도로 하드 코딩한 값을 반환하는 구현체를 스텁이라고 한다.
- 생성자 주입으로 DI 하면 테스트 코드에서 스텁을 생성해 생성자로 호출한다.

## 목 주입을 위한 어노테이션들
- @Mock 어노테이션은 목을 합성하고자 하는 곳을 의미한다.
- @InjectMocks 는 목을 주입하고자 하는 대상을 의미한다.
- 인스턴스를 생성하고 MockitoAnnotations.initMocks(this) 를 호출한다.
- this 는 테스트 클래스 자체를 의미하고 @Mock 이 붙은 필드를 가져와서 각각에 대해 목 인스턴스를 합성한다.
- @InjectMocks 가 붙은 필드를 가져와서 목객체들을 거기에 주입한다.
- 목 객체를 주입하려고 모키토는 먼저 사용할 적절한 생성자를 탐색한다.
- 아무것도 없으면 적절한 세터를 탐색한다. 마지막으로는 적절한 필드를 찾는다. -> 생성자가 없어도 되는 이유
- 모키토는 필드 수준 주입을 지원한다.
- 목을 사용한 테스트는 진행하길 원하는 내용을 분명하게 기술해야한다.
- 목이 실제 동작을 대신한다. 목은 프로덕션 코드를 직접 테스트하고 있지 않다.
- 목을 도입하면 테스트 커버리지에서 간극을 형성할 수 있음을 인지해야한다.

# 멀티스레드 코드
1. 스레드 통제와 애플리케이션 코드 사이의 중첩 최소화
   - 스레드 없이 다량의 애플리케이션 코드를 단위 테스트할 수 있도록 설계해야한다.
   - 남은 코드에 대해 스레드에 집중적인 테스트를 작성하라
2. 다른 사람의 작업 믿기
  - 자바5에는 동시성 유틸리티 클래스가 있다.
  - 생산자, 소비자 문제를 직접 코딩하지 말고 다른 사람들이 직접 써보며 검증한 BlockingQueue 클래스를 사용하라

- 메서드에 대한 동작 테스트와 스레드 테스트를 분리해서 테스트한다.
- ExecutorService 와 같은 객체에 참조가 필요할때는 get 메서드를 만들자

## 데이터베이스 테스트
- 데이터베이스가 트랜잭션을 지원한다면 테스트마다 트랜잭션을 초기화 하고 테스트가 끝나면 롤백하자 @Before, @After

- 관심사를 분리시키자. 애플리케이션 로직은 스레드, 디비 문제를 일으킬 수 있는 다른 의존성과 분리하자.
- 느리거나 휘발적인 코드를 목으로 대체하여 의존성을 끊자
- 필요한 경우에는 통합 테스트를 작성하되, 단순하고 집중적으로 만들자

# 프로젝트에서 테스트
## 단위 테스트 표준 만들기
- 코드를 체크인 하기 전에 어떤 테스트를 실행해야할지 여부
- 테스트 클래스와 메서드의 이름 짓는 방식
- 햄크레스트 혹은 전통적인 단언 사용 여부
- AAA 사용여부
- 선호하는 목 도구
- 체크인 테스트를 실행할 때 콘솔에 출력을 허용할지 여부
- 단위 테스트에서 느린 테스트를 분명히 식별하고 막을 방법

## 코드 커버리지
- 엠마, 코버투라는 코드 커버리지 도구의 예이다.
- 클래스 내의 메서드를 모두 호출하는 단위 테스트를 실행하면 커버리지는 100%가 된다.
- 분기 커버리지는 조건문 분기에 따라 커버리지를 측정하는 방식이다.
- 커버리지는 인자 없는 생성자를 제공하는 프레임워크에서는 100%를 맞출 수 없다.
- 70% 이하의 커버리지는 불충분(엠마의 제조사)
- 설계가 좋을 수록 테스트 작성이 쉬워진다.
