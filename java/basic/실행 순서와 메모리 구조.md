# java 실행 순서
1. 자바 파일을 javac 로 컴파일 하면 ``.class``확장자로 변환시켜 준다.
2. 컴파일이 완료된 파일을 실행시키면 JVM이 운영체제로부터 프로그램 실행을 위한 메모리를 할당 받는다.
3. ``.class`` 파일은 JVM의 ``class loader`` 에게 보내진다.
4. ``class loader`` 는 ``.class`` 파일의 바이트 코드를 엮어서 JVM내의 ``RunTime Data`` 영역에 배치한다. 작성한 프로그램이 실행되는 영역이 ``RunTimeData`` 영역이다.
5. ``Execution Engine`` 이 클래스 로더를 통해 JVM 내의 ``Runtime Data`` 영역에 배치된 바이트 코드들을 명렁어 단위로 읽어서 실행한다.
6. ``Execution`` 은 interpreter 방식과 Jit 방식을 동시에 사용하고 있다.
   - interpreter 는 한줄 한줄 읽어오는거라서 느린데 jit 은 한번에 모두 컴파일해서 native code로 변경한다. 하지만 jit도 한번에 하면 비용이 많이 들기 때문에 자바에서는 인터프리터를 사용하다가 일정 기준이 넘어가면 Jit 을 사용한다.


# jvm 메모리 구조
> ``RunTime Data`` 영역은 JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다.

![img](https://velog.velcdn.com/images%2Fplz_no_anr%2Fpost%2F63e67428-ff8c-4e3f-b3a7-b0a8ffb82872%2FJVM.png)

## Method = static
- 모든 스레드가 공유하는 영역이다. 프로그램 전체에 공유된다.
- 클래스 파일 정보, 변수의 정보와 같은 클래스 구조와 static 필드들이 저장된다.
- 프로그램이 시작되고 종료시까지 유지된다.

### runtime constant pool
- 각 클래스/인터페이스마다 가지고 있는 pool 이다.
- 클래스 생성시 참조 해야 할 정보들을 상수로 가지고 있다.
- 메소드나 필드의 실제 메모리상 주소가 저장되어있다.
- 상수 자료형을 저장하여 참조한다.

## Heap
- 모든 스레드가 공유하는 영역이다.
  - 동시성 이슈가 발생할 수 있다.
- new 연산자로 생성되는 클래스와 인스턴스 변수, 배열 타입 등 참조 자료형이 저장
- 더이상 참조되지 않는 객체는 가비지 컬렉터가 삭제한다.
- 동적 메모리 할당이 가능해 프로그램 실행 중에 메모리크기가 가변적으로 할당된다.
- 메모리 크기가 유동적이지만 동적으로 할당된 메모리가 제대로 해제되지 않는 경우 메모리 누수가 발생할 수 있다.

## Stack
- 각 스레드마다 개별 생성되는 영역이다.
- 메소드의 작업에 필요한 메모리 공간을 제공한다. 메소드 호출마다 각각의 스택이 생성되며 메석드가 작업을 마치면 스택도 함께 사라진다.
- 기본 자료형을 생성할 때 저장되는 공간으로 임시적으로 사용되는 변수나 정보들이 들어간다.
- 메서드 안에서 사용되는 값들을 저장하고 호출된 메서드의 매개변수, 지역변수, 리턴 값, 연산시 발생하는 값들을 임시로 저장한다.
- 정적 메모리 할당으로 컴파일시에 크기가 결정되며, 초과시 stackOverFlow 에러가 발생한다.
- 데이터 접근방식이 단순하고 속도가 빠르다. FIFO

## PC Register

## Native Method Stack