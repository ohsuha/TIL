# Hash
임의의 크기를 가진 타입의 데이터를 고정된 크기를 가지는 int 데이터로 변환하는 hash function 함수를 이용해 해시값을 만든다.
hash function을 통해 만들어진 정수값을 hash 라고 한다. hash 는 유한하며 범위가 좁다.

## 저장
1. 키 값을 hash function에 넣어 해시값을 만든다. : 예) "TIL" -> 202
2. 실제로 값을 저장하는 배열을 capacity라 하고 각각의 배열은 bucket, slot 이라고 부른다.
3. capacity 가 8이라면 bucket 은 8개 있고 데이터는 8개 중에 하나에 들어가야한다.
4. 만들어진 해시값을 %8(capacity) 로 계산한다. : 예) 202 % 8 = 2
5. 위에서 나온 값을 bucket 의 index로 해서 bucket 에 저장시킨다.

## 읽기
1. 키 값을 넣어 검색하면 키값이 hash function 에 의해 hash 값으로 변경된다.
2. 변경된 값을 capacity 값으로 % 연산을 한다.
3. 나온 값으로 해당하는 인덱스로 간다.
  - 이때 인덱스가 겹치는 다른 값이 들어있을 수 있다. (해시 충돌)
  - 이를 해결 하기 위해 해당하는 키로 쓰인 값도 같이 bucket 에 저장된다.
4. 키 값과 조회하려던 데이터가 키값이 맞는지 equals 비교를 하고 같다면 리턴한다.

## 해시 충돌
> hash function 을 거치면 유한한 줄어든 범위의 값으로 변환 시키는 것이다. 범위를 줄이다 보니 같은 해시가 발생할 수 밖에 없다.
1. key 는 다른데 hash가 같을때
2. key도 hash 도 다른데 해시 값을 %(모듈러) 연산 한 값이 같을 떄

### separate chaining
버킷 하나하나를 링크드 리스트로 관리하는 방식이다.
여러개의 키, 밸류 페어를 링크드 리스트로 연결 시켜서 찾을때는 인덱스로 버킷을 찾고 버킷의 링크드 리스트에서는 키로 검색해 찾는다.

### open addressing
여러가지 방식이 있는데 그 중 리니어 프로빙(linear probing)은 이미 해당 인덱스에 데이터가 있으면 바로 다음 인덱스에 저장하는 방식이다.
데이터를 읽어올때도 먼저 해당 인덱스를 간 후 값이 일치하지 않으면 다음 버킷의 키를 비교해본다.
값을 지우게 되면 아래 인덱스에 있던것이 위로 올라오거나, dummy data라고 하는 것을 삭제할 인덱스에 넣어줘야한다. (충돌이 난 다음 데이터를 찾기 위해)


## resizing
java의 경우 capa 의 3/4 이상이 데이터가 차있으면 capa 를 2배로 늘리는 리사이징을 한다.
값을 버킷에 저장할때는 hash 값도 같이 저장하는데(한번 저장해 놓고 빠르게 찾아오기 위해서) 이 hash 값을 바뀐 capacity 에 맞춰 % 연산을 해 재배치한다.

- hashMap, hashSet 에서 hashcode() 를 수정하면 왜 equals() 도 수정해야하는지