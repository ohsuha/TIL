# lambda
## 왜 생겼을까?
디폴트 메서드를 화용해 컬렉션을 강화하였고, 거대한 컬렉션을 분산 환경에서 다루기 위한 병렬화 기술이 강화되었다.
그리고 이 컬렉션을 좀 더 효율적으로 다루기 위해 스트림이 강화되었고, 스트림을 편리하게 사용하기 위해 선언형-함수형 프로그래밍이 도입되었다.
그리고 선언형, 함수형 프로그래밍을 위해 람다가 도입되었다. 즉 컬렉션을 효율적으로 편리하게 잘 다루기 위해 생겨났다.

## 람다란 무엇인가?
- 메서드를 하나의 식으로 표현한 것이다. 익명함수라고도 한다. 
- 메서드의 매개변수로 전달되어지는 것이 가능하고, 메서드의 결과로 반환될 수도 있다.
- 람다식으로 인해 메서드를 변수처럼 다루는 것이 가능해짐.
- 람다는 사실 메서드가 아닌 익명 클래스의 객체이다.
- 컴파일러는 람다식의 타입을 외부클래스의 이름을 이용해서 만든다. 람다식의 경우 외부클래스이름$$Lambda$번호와 같은 형식을 갖는다.
- 람다식은 익명 객체이므로, 참조하는 클래스의 지역변수를 final로 만든다.

### 왜 익명 클래스는 final 만 참조가 가능한가?
메서드 안에 위치한 지역클래스나 익명 클래스에서 외부의 지역변수를 사용하기 위해서는 final 지정을 해야만 사용이 가능하다.

> "메서드가 수행을 마쳐서 지역변수가 소멸된 시점에도, 지역(익명) 클래스의 인스턴스가 소멸된 지역변수를 참조하려는 경우가 발생할 수 있기 때문이다."

1. 지역변수를 final로 지정하면 JVM constant pool에서 따로 변수를 관리한다.
2. 따라서 지역클래스를 포함하고 있는 메서드와 메서드 안에 있는 final 지역변수는 생명주기가 달라진다.
3. 이 이유로 메서드가 가비지컬렉션에 반납되어도 메서드 안의 final 지역변수는 constant pool에서 계속 보관하고 있기 때문에 이를 참조하고 있는 지역 클래스의 인스턴스는 문제없이 동작할 수 있다.
4. 즉, 생명주기가 달라지면 동작의 안전성을 보장하지 못하므로 지역(익명)클래스에서 외부의 변수를 사용하기 위해서는 final로 지정된 변수를 사용하도록 하고 있다.

`constant pool`을 쉽게 설명하자면, **JVM이 자주 사용되는 값을 효율적으로 관리하기 위해 사용하는 특별한 메모리 공간**입니다. 주로 문자열 상수나 숫자 같은 기본적인 상수들이 이곳에 저장됩니다.

1. **final 지역변수**는 **한 번 값을 정하면 바꿀 수 없기 때문에** 그 값을 별도로 메모리에 저장할 수 있습니다. 이때 JVM은 이 값을 **constant pool**에 저장할 수 있습니다.

2. 보통 메서드가 끝나면 그 안에서 사용한 변수는 메모리에서 사라집니다. 하지만 `final`로 지정된 변수는 메서드가 끝나도 계속 **constant pool**에 남아있을 수 있습니다.

3. 이런 이유로, **익명 클래스나 내부 클래스**가 메서드 안에서 정의되었더라도, `final`로 선언된 변수는 메서드가 끝난 후에도 계속 참조할 수 있는 것이죠.

정리하자면, `constant pool`에 저장된 값들은 JVM이 **따로 관리하고 보관**하므로 메서드가 끝나도 그 변수를 계속 사용할 수 있습니다. 그렇기 때문에 **final**로 선언된 변수를 사용하는 것이 안전한 거죠.

지역 클래스와 `final`로 선언된 지역 변수의 생명주기가 다르다는 점은 중요한 개념입니다. 이를 이해하려면, **지역 클래스**와 **지역 변수**가 어떻게 메모리에서 관리되는지를 생각해 봐야 해요.

### 1. **지역 변수의 생명주기**
지역 변수는 보통 **메서드가 실행되는 동안**에만 존재합니다. 즉, 메서드가 끝나면 지역 변수는 메모리에서 제거됩니다. 하지만 **`final`로 선언된 지역 변수**는 다릅니다. 이 변수는 메서드가 끝나도 **JVM의 constant pool**에 저장되어 계속 존재할 수 있어요.

### 2. **지역 클래스의 생명주기**
지역 클래스는 **메서드 안에서 선언된 클래스**로, 그 **인스턴스**가 만들어질 때부터 지역 클래스가 참조하는 변수들이 필요하게 됩니다.

- 지역 클래스가 메서드 내부에서 생성되고 그 인스턴스가 다른 곳에서 계속 참조될 수 있습니다.
- 즉, 메서드가 끝나더라도 그 지역 클래스의 **인스턴스가 살아있는 한** 지역 클래스는 계속 사용할 수 있습니다.

### 3. **생명주기의 차이**
- 보통 메서드가 끝나면, 지역 변수는 사라집니다. 하지만 **`final`로 선언된 지역 변수는 constant pool에 저장**되어, 메서드가 끝나더라도 **지역 클래스가 그 변수를 계속 사용할 수** 있습니다.
- 반면 **지역 클래스의 인스턴스는 메서드가 끝난 후에도 존재**할 수 있으며, 그 안에서 `final` 지역 변수를 참조하는데 문제없이 동작합니다.

결론적으로, **메서드가 종료되어도 `final` 지역 변수는 constant pool에서 유지**되므로 **메서드가 끝난 후에도 지역 클래스 인스턴스가 그 변수를 안전하게 참조**할 수 있는 것이죠.


### 1. 기본 개념 이해하기
자바에서는 보통 메서드를 사용해 어떤 동작을 정의하죠. 예를 들어, 두 숫자를 더하는 메서드는 이렇게 생겼을 거예요:

```java
public int add(int a, int b) {
    return a + b;
}
```

이 메서드는 `add`라는 이름을 가지고 있고, `a`와 `b`라는 두 개의 매개변수를 받아서 그 합을 반환해요.

### 2. 익명 클래스의 문제점
자바에서는 보통 인터페이스를 사용해 특정 동작을 정의하고, 그 동작을 구현하는 클래스를 작성해요. 예를 들어, `Runnable`이라는 인터페이스를 구현할 때, 아래처럼 익명 클래스를 사용할 수 있어요:

```java
Runnable runnable = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello, World!");
    }
};
```

위 코드는 `Runnable` 인터페이스를 구현하는 익명 클래스를 만들고, `run` 메서드를 오버라이드해서 "Hello, World!"를 출력하는 코드예요.

**하지만 코드가 너무 길죠?** 익명 클래스를 사용할 때는 항상 이렇게 긴 코드를 작성해야 하니, 불편할 수 있어요.

### 3. 람다식 도입
람다식은 이러한 익명 클래스를 간결하게 작성할 수 있도록 도와주는 문법이에요. 위의 `Runnable` 예제를 람다식으로 바꿔보면 이렇게 줄일 수 있어요:

```java
Runnable runnable = () -> System.out.println("Hello, World!");
```

보세요! 훨씬 간결해졌죠? 이제 하나씩 살펴볼게요.

### 4. 람다식의 기본 구조
람다식의 기본 구조는 다음과 같아요:

```java
(매개변수들) -> { 함수의 몸체 }
```

이 구조를 통해 익명 클래스를 단순하게 표현할 수 있어요. 위에서 봤던 예제들을 다시 한 번 뜯어볼게요:

```java
() -> System.out.println("Hello, World!");
```

- `()` : `run` 메서드가 매개변수를 받지 않기 때문에 빈 괄호를 사용해요.
- `->` : 화살표 연산자는 람다식의 시작을 나타내요.
- `System.out.println("Hello, World!");` : 이 부분이 실제 실행될 코드예요.

### 5. 예제: 두 수의 합을 구하는 람다식
이제 두 숫자를 더하는 람다식을 만들어볼게요:

```java
(int a, int b) -> { return a + b; }
```

하지만 자바는 코드의 맥락(context)을 통해 매개변수의 타입을 추론할 수 있어요. 그래서 타입을 생략할 수도 있죠:

```java
(a, b) -> { return a + b; }
```

심지어 더 간단하게 만들 수 있어요. `return`이 필요한 단일 표현식이 있을 때는 중괄호 `{}`와 `return` 키워드를 생략할 수 있거든요:

```java
(a, b) -> a + b
```

### 6. 실전 적용
이제 실전에서 람다식을 어떻게 사용하는지 봅시다. 자바에는 `Functional Interface`라는 특별한 인터페이스들이 있는데, 이들은 하나의 추상 메서드만 가져요. 이런 인터페이스들은 람다식으로 쉽게 구현할 수 있어요.

예를 들어, `Function` 인터페이스는 하나의 입력을 받아 하나의 출력을 반환하는 함수형 인터페이스예요:

```java
Function<Integer, Integer> square = x -> x * x;
System.out.println(square.apply(5)); // 출력: 25
```

여기서:
- `Function<Integer, Integer>`는 입력과 출력이 모두 `Integer` 타입인 함수를 나타내요.
- `x -> x * x`는 입력값 `x`를 받아서 `x * x`를 반환하는 람다식이에요.

# Stream
Stream API는 컬렉션, 배열 등의 데이터 소스를 스트림으로 만들어 작업하기 위한 기능을 제공하기 위해 Java 8 때 등장하였다.

## 기본 특징
1. 스트림은 데이터 소스를 변경하지 않는다. 스트림은 데이터 소스로 부터 데이터를 읽어오기만 한다. 소스를 변경하지 않는다.
2. 스트림은 일회용이다. 스트림은 Iterator와 같이 일회용이다. 스트림을 한번 사용하고 나면, 재사용이 불가능하다.
3. 스트림은 작업을 내부 반복으로 처리한다 반복문을 메서드 내부에 숨김으로써, 간결함을 가질 수 있었다.

## 중간 연산
중간연산(intermediate operation)은 기본적으로 메서드 체이닝 방식으로 서로 연결되어 파이프라인을 구성할 수 있다. 이는 각각의 중간연산이 스트림을 반환한다는 점을 의미한다.
실제로 filter, map, limit, sorted 등 모든 중간연산의 반환형은 Stream으로 정의되어 있다.

## 최종 연산
최종연산(terminal operation)의 경우 스트림 파이프라인의 마지막에 실행되어야 하는 연산임을 쉽게 유추할 수 있을 것이다.
실제로 최종연산은 중간연산과는 달리 Stream이 아닌 void, long, 컬렉션 등을 반환하기 때문에 그 결과에 대해 또 다른 스트림 연산을 적용할 수 없다. 그런데 이보다도 중요한 특징은 바로 스트림을 소비한다는 점이다. 스트림에 최종연산을 적용하게 되면 해당 스트림은 소비된 것으로 간주되며,
이미 소비된 스트림에 대해 스트림 연산을 적용하는 경우 예외가 발생한다.
그리고 바로 이 점 때문에 최종연산은 언제나 파이프라인의 마지막에 위치하게 된다.
최종 연산은 반환값이 스트림이 아니고, 스트림을 소모하는 연산으로, 마지막에 호출되어야 한다.
최종연산이 호출된다면, 스트림을 닫히게 되어 더 이상 사용할 수 없게 된다.
따라서 단 한번만 호출이 가능하다.

## 지연 연산
Java 스트림이 **지연 연산(lazy evaluation)**을 선택한 이유는 **효율성과 성능 최적화**에 있습니다. 지연 연산의 주요 이유와 장점은 다음과 같습니다.

### 1. **최소한의 연산으로 성능 최적화**
스트림은 데이터를 처리하는 연속된 작업들을 **필요할 때 한꺼번에 처리**합니다. 즉, 중간 연산(`filter`, `map` 등)은 실제로 결과를 바로 계산하지 않고, **최종 연산**(`collect`, `forEach` 등)이 호출될 때 연산을 시작합니다. 이로 인해, **불필요한 연산을 피하고 필요한 연산만 수행**하는 방식이 가능합니다.

#### 예시:
```java
List<String> names = Arrays.asList("John", "Jane", "Tom", "Alice");
names.stream()
    .filter(name -> name.length() > 3)
    .map(name -> name.toUpperCase())
    .limit(2)
    .forEach(System.out::println);
```

위 코드에서 `limit(2)`는 이름이 3자 이상인 첫 두 개의 문자열만 변환하고 출력합니다. 만약 지연 연산이 없었다면, `filter`와 `map`이 전체 리스트에 대해 모두 처리된 후 `limit(2)`가 적용되었을 것입니다. 하지만 **지연 연산 덕분에** 필요한 두 개의 요소만 처리되고 나머지 요소는 연산하지 않으므로 **불필요한 작업을 줄일 수 있습니다**.

### 2. **파이프라인 방식으로 데이터를 처리**
지연 연산을 통해 **스트림의 모든 중간 연산이 하나의 파이프라인처럼 연결**됩니다. 이때, 각 요소에 대해 중간 연산이 완료된 후 다음 요소로 넘어가는 방식으로 작동합니다. 즉, **모든 요소에 대해 하나씩 처리**하며 다음 연산으로 전달하므로, 데이터를 처리하는 **흐름이 자연스럽고 효율적**입니다.

### 3. **메모리 절약**
지연 연산은 **필요한 만큼만 데이터를 처리**하기 때문에, 메모리 사용량을 최소화합니다. 예를 들어, `filter`와 같은 연산이 전체 데이터셋을 처리한 후 메모리에 새로운 결과를 저장하지 않고, 필요한 시점에 연산을 시작해 메모리 낭비를 줄입니다.

### 4. **불필요한 계산 회피**
지연 연산 덕분에, 스트림은 **최종 연산이 필요할 때만 데이터를 처리**합니다. 만약 최종 연산이 없으면, 중간 연산들도 아예 수행되지 않습니다. 이는 성능을 최적화하는 중요한 이유 중 하나입니다.

### 5. **루프 퓨전 (Loop Fusion)**

**루프 퓨전**은 여러 개의 루프를 하나로 합쳐서 성능을 최적화하는 방법입니다. Java 스트림에서는 중간 연산이 여러 개 연결될 때, **각 연산을 따로따로 처리하지 않고** 하나의 루프로 합쳐서 실행합니다. 이를 통해 여러 번 데이터를 반복하는 것을 방지하고 성능을 높입니다.

#### 예시:
```java
List<String> names = Arrays.asList("John", "Jane", "Tom", "Alice");
names.stream()
    .filter(name -> name.length() > 3)
    .map(name -> name.toUpperCase())
    .forEach(System.out::println);
```

위 예제에서는 `filter`와 `map`이 각각 개별적으로 반복되는 것이 아니라, **하나의 루프로 합쳐져서** 각 요소에 대해 `filter`가 적용된 후, `map`이 바로 적용되는 방식으로 처리됩니다. 이게 바로 **루프 퓨전**입니다. 이로 인해, 각 요소에 대해 **한 번의 루프에서 여러 연산을 처리**할 수 있어 성능이 향상됩니다.

#### 루프 퓨전과 지연 연산의 관계
지연 연산은 중간 연산을 바로 실행하지 않으므로, 모든 연산을 하나의 루프에서 결합하여 효율적으로 처리할 수 있습니다.

루프 퓨전은 Java 스트림의 지연 연산이 가능한 이유 중 하나입니다. 지연 연산에서는 중간 연산들이 즉시 실행되지 않고 최종 연산이 호출될 때 한 번에 처리되기 때문에, 각각의 중간 연산을 별도로 계산하지 않습니다.

Java 스트림의 파이프라인에서 여러 중간 연산이 지연된 상태로 남아 있다가, 최종 연산이 호출될 때 실제로 모든 연산을 하나의 루프에서 실행합니다. 이게 바로 루프 퓨전을 통해 이루어지는 것이죠.

루프 퓨전과 지연 연산의 작동 방식: 각 연산이 따로따로 즉시 실행되는 대신, 필요한 시점에 한 번의 루프로 모든 중간 연산을 결합하여 처리합니다. 이로 인해 메모리 사용을 최소화하면서, 최적화된 방식으로 데이터 처리가 가능합니다.

예시에서 filter, map 연산이 각각 따로 실행되는 것이 아니라, 최종 연산이 실행될 때 이 두 연산을 하나의 루프에서 처리하는 방식이 바로 루프 퓨전과 지연 연산이 결합된 예입니다.

### 6. **쇼트 서킷 (Short-Circuit)**

**쇼트 서킷**은 **필요한 만큼만 계산하고, 더 이상 필요하지 않으면 남은 연산을 건너뛰는 것**을 의미합니다. Java 스트림에서는 `limit`, `findFirst`, `anyMatch`와 같은 연산이 쇼트 서킷을 지원합니다. 이러한 연산은 **필요한 조건을 만족하면 즉시 연산을 종료**하므로 불필요한 계산을 방지하고 성능을 최적화할 수 있습니다.

#### 예시:
```java
List<String> names = Arrays.asList("John", "Jane", "Tom", "Alice");
names.stream()
    .filter(name -> name.length() > 3)
    .map(name -> name.toUpperCase())
    .limit(2)
    .forEach(System.out::println);
```

위 코드에서 `limit(2)`는 **첫 두 개의 요소만 처리**하고 나머지는 계산하지 않습니다. `filter`와 `map`이 첫 두 개의 요소에 대해 적용된 후, 스트림 처리가 중단됩니다. 이는 **쇼트 서킷**에 해당하며, 전체 리스트를 처리할 필요 없이 **최소한의 연산으로 결과를 얻을 수 있게 합니다**.

#### 쇼트 서킷과 지연 연산의 관계
지연된 상태에서 필요할 만큼만 계산하고, 조건이 충족되면 불필요한 나머지 계산을 생략할 수 있습니다.
지연 연산 덕분에 중간 연산들이 바로 계산되지 않으므로, 최종 연산이 수행되기 전에 필요한 만큼만 연산하고 나머지는 건너뛸 수 있습니다.

즉, 지연 연산 덕분에 쇼트 서킷은 다음과 같이 작동할 수 있습니다: 
1. 조건이 충족되면 즉시 계산을 멈추고 더 이상의 계산을 수행하지 않음: 지연 연산을 사용하지 않았다면, 스트림의 모든 요소가 먼저 처리된 후 쇼트 서킷이 적용되었을 것입니다.
2. 쇼트 서킷 연산은 limit, findFirst, anyMatch와 같은 최종 연산에서 주로 나타나며, 지연 연산을 통해 필요하지 않은 데이터는 계산조차 하지 않고 건너뜁니다.


## 스트림은 언제 사용하는게 좋을까?
아래와 같은 상황에선 스트림을 지양하자.
1. 범위 안의 지역변수를 읽고 수정해야 하는 경우 -> 람다에서는 변화하지 않는 상태를 다루는 것이 일반적이므로 부적절
2. return, break, continue등의 세밀한 반복 제어가 필요할 때
3. 검사 예외를 던질 때
4. 다음 단계에서 이전 단계의 상태 정보가 필요할 떄 (스트림은 데이터를 버린다)

그리고 아래와 같은 상황에선 스트림이 적절하다.
1. 원소들의 시퀀스를 일관되게 변환하거나, 필터링 할 때
2. 원소들의 시퀀스를 한가지의 규칙(연산)을 사용해 결합할 때
3. 원소들의 시퀀스를 특정 컬렉션에 모을떄
4. 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾아낼 때

# 참조
https://dwaejinho.tistory.com/entry/Java-Lambda-Stream-%EB%8F%84%EC%9E%85-%EB%B0%B0%EA%B2%BD%EA%B3%BC-%EC%9B%90%EB%A6%AC-%ED%8C%8C%ED%95%B4%EC%B9%98%EA%B8%B0#1.10%20%EC%99%B8%EB%B6%80%20%EB%B3%80%EC%88%98%EB%A5%BC%20%EC%B0%B8%EC%A1%B0%ED%95%98%EB%8A%94%20%EB%9E%8C%EB%8B%A4%EC%8B%9D-1
