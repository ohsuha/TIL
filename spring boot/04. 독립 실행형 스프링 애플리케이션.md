# 독립 실행형 스프링 애플리케이션
- 독립 실행이 가능한 spring 어플리케이션을 어떻게 만들 것 인가?
- 서블릿과 관련된 코드들을 애플리케이션 개발 중 신경쓰지 않고 개발할 수 있을까?
- 이전에 만들었던 프론트 콘트롤러가 스프링 컨테이너의 hello controller 로 보내 보자

## 스프링 컨테이너 사용
### 스프링 컨테이너
1. 비즈니스 로직을 담고 있는 POJO 오브젝트 : 애플리케이션 코드
2. 만들어진 코드를 어떤식으로 구성할지 구성 정보를 담고 있는 configuration meta data 

스프링 컨테이너는 이 두가지를 조합하여 사용 가능한 시스템을 만든다.
스프링 컨테이너가 내부에서 우리가 만든 1, 2 를 조합해서 스프링 컨테이너 내에 빈으로 만들어서 서버 애플리케이션으로 만들어 준다.

```java
GenericApplicationContext genericApplicationContext= new GenericApplicationContext();//spring container
//어떤 클래스를 이용해 bean 메타 정보를 만들 것인가가 필요함
genericApplicationContext.registerBean(HelloController.class);
//bean 을 어떤 클래스로 만들것인가 등등의 정보를 등록함
genericApplicationContext.refresh();

webServer= serverFactory.getWebServer(servletContext -> {
servletContext.addServlet("hello", new HttpServlet() {
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        if(req.getRequestURI().equals("/hello") && req.getMethod().equals("GET")) {
            String name = req.getParameter("name");
            HelloController helloController = genericApplicationContext.getBean(HelloController.class);
            String result = helloController.hello(name);

            resp.setContentType(MediaType.TEXT_PLAIN_VALUE);
            resp.getWriter().println(result);
        }
    }
}).addMapping("/hello");
});

webServer.start();
```

근데 오히려 번거롭게 왜 이렇게 할까?
- 스프링 컨테이너는 등록된 빈의 객체를 딱 한번만 만든다.
- 프론트 컨트롤러와 또다른 서블릿이 같은 헬로 컨트롤러 빈을 사용할떄 만들어둔 하나의 인스턴스를 재사용시켜준다.
  - 싱글톤 패턴을 사용한것과 유사하게 타입의 오브젝트를 하나만 만들고 재사용할 수 있게 해준다.
- 역할에 따라서 오브젝트를 분리해서 만들고 다른 오브젝트한테 이런 기능을 수행해달라고 요청할때가 있다.
  - controller 와 service 를 분리

## 의존 오브젝트 추가
- helloControllerService 를 추가하여 서비스 로직을 controller 가 아닌 service에서 수행하도록 작업을 위임했다.

## Dependency Injection, 의존 오브젝트 DI 적용
spring Container의 어셈블러가 자동으로 생성자에 구현체를 맵핑해주는 기술
스프링 컨테이너가 빈으로 등록된 것을 어셈블러를 통해서 DI, 헬로 컨트롤러에 주입해주는 과정을 해보자

```java
public interface HelloService {
	String sayHello(String name);
}
```

```java
public class HelloController {

	private final HelloService helloService;
	//final 이니까 생성자나 어디서나 초기화가 필요하다고 컴파일 에러가 발생한다.

	public HelloController(HelloService helloService) {
		this.helloService = helloService;
	}

	public String hello(String name) {
		//SimpleHelloService simpleHelloService = new SimpleHelloService();
		//직접 인스턴스를 만들지 않고 어셈블러에 의해 헬로 컨트롤러 클래스의 객체를 만들때 생성자 파라미터로 주입할 수 있도록 변경 하자

		return helloService.sayHello(Objects.requireNonNull(name));
		// 만약 null 이면 예외를 던진다.
		// null 인 경우를 방지 하고 null 이 아닐 때만 사용 가능
	}
}
```

```java
public class SimpleHelloService implements HelloService {
	@Override
	public String sayHello(String name) {
		return "Hello " + name;
	}
}
```

```java
[main]

GenericApplicationContext genericApplicationContext= new GenericApplicationContext();
genericApplicationContext.registerBean(HelloController.class);
// genericApplicationContext.registerBean(HelloService.class); // 인터페이스지 클래스가 아님
genericApplicationContext.registerBean(SimpleHelloService.class);
//초창기에는 xml으로 빈을 지정해서 생성자에 어떤 빈을 주입할지 정보도 다 기술을 해줬어야했다

genericApplicationContext.refresh();

webServer= serverFactory.getWebServer(servletContext -> {
    servletContext.addServlet("hello", new HttpServlet() {
        protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            if(req.getRequestURI().equals("/hello") && req.getMethod().equals("GET")) {
                String name = req.getParameter("name");

                HelloController helloController = genericApplicationContext.getBean(HelloController.class);
                String result = helloController.hello(name);

                resp.setContentType(MediaType.TEXT_PLAIN_VALUE);
                resp.getWriter().println(result);
            }
        }
    }).addMapping("/hello");
});

webServer.start();
```


## DispatchServlet 으로 전환

## 애노테이션 매핑 정보 사용

## 스프링 컨테이너로 통합

## 자바 코드 구성 정보 사용

## @Component 스캔

## Bean 의 생명주기 메소드

## SpringBootApplication