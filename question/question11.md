# 레디스는 왜 빠를까?
## 레디스의 특별한 자료구조
보통 데이터베이스 인덱스 구조에는 B Tree 를 사용하지만 Btree 는 여러 단점이 있다.
레디스는 Skip List 를 사용해서 이런 단점을 해결하고 동시성 문제를 더 잘해결한다.

### skip list
장점
- 키들이 정렬되어있다.
- O(log n) 수준 복잡도를 가진다. 모든 연산(검색, 삭제, 삽입)에 이런 복잡도가 보장된다.
- 각각의 상위 레벨은 하위 레벨보다 절반 개수의 원소를 가진다.
- BTree 의 밸런싱 비용에 비해 구현하기 쉽고, 링크 재조정이 이뤄지는 횟수가 적어서 덜 소모적이다.
- 스킵 리스트에 존재하는 각각의 노드들은 랜덤한 레벨을 할당 받는데, 레벨 i에 대해서 레벨이 i 이상인 노드들 사이에는 다음 노드로 이동할 수 있는 포인터가 있다.

단점
- 메모리 사용량이 많다. 왜냐면 각각의 레벨에 대해서 많은 수의 링크를 필요로하기 때문에 N*(N+1) / 2 만큼의 공간이 필요하다.

## 인메모리 스토리지
메모리에 있기 때문에 빠르다. 순수하게 메모리에 접근하는 방식은 높은 읽기 쓰기 성능을 보장한다.
대신 데이터 셋의 크기 자체가 메모리 보다 커질 수 없다.
저장되는 데이터의 크기를 포기한 대신 빠른 성능을 보장해준다.
레디스의 이론상 수용 가능한 최대 키 개수는 2억 5천만개의 키이다.
하드웨어의 메모리를 전부 소모하지 않기 위한 방어로직도 가진다. 여기에 도달하면 쓰기연산에 대해 에러를 응답,
반면 읽기 전용 연산은 잘 수행된다.

## 레디스의 I/O모델
epoll 모델을 사용하는데 동시에 많은 클라이언트가 요청해도 하나하나 대기하지 않고 한번에 요청을 모아서 빠르게 처리한다.
1. 모니터링 준비: epoll은 Redis 서버가 연결된 여러 클라이언트들의 요청이 발생하는지 계속 감시하고 있습니다.
2. 이벤트 발생 알림: 만약 특정 클라이언트에서 요청이 발생하면, Redis는 epoll을 통해 이를 바로 알 수 있습니다.
3. 즉각적인 처리: 감지된 요청에 대해, Redis는 순서대로 빠르게 요청을 처리하고 다시 다음 요청을 기다립니다.

이 방식 덕분에, Redis는 클라이언트의 요청을 비효율적으로 대기열에 쌓지 않고, 
필요한 것만 처리해 응답하는 고속 네트워크 성능을 구현할 수 있습니다. 
epoll을 사용하지 않는 전통적인 방법들은 각 요청을 일일이 확인해야 하는 오버헤드가 발생하지만,
epoll은 변경된 요청에 대해서만 감시하므로 자원 사용을 최소화하면서 속도를 높일 수 있습니다.

기존의 select나 poll 같은 방식에서는 서버가 연결된 모든 클라이언트 소켓을 매번 하나씩 확인해야 합니다.
즉, 각 클라이언트가 요청을 보냈는지 여부를 매번 전체 순회하면서 체크해야 하므로, 불필요한 반복 작업이 많아질 수밖에 없죠.
epoll에서는 실제 변화가 발생한 소켓(즉, 요청이 도착한 소켓)에 대해서만 알려주기 때문에 매번 전체 소켓을 확인하지 않아도 됩니다.

# 큐를 사용한 동시성 관리 방법 자세히 찾아보기
1. 각 서버가 큐에 요청을 쌓을 수 있도록 메시지 큐를 설정한다.
2. 데이터베이스 접근 작업에 대한 큐를 만들고, 큐의 메시지 소비 속도를 설정하여 서버의 부하를 관리
3. 서버에서 디비에 접근이 필요할때 즉시 접근하지않고, 큐에 요청을 메시지 형태로 추가한다. 각 요청에는 작업에 필요한 데이터나 작업 유형을 포함시킨다.
4. 큐에 쌓인 요청을 하나씩 꺼내서 처리하는 consumer 를 통해 메시지를 가져와서 해당 작업을 수행한다.
5. consumer 가 메시지를 받아 디비 작업ㅇ르 수행한다. 이때 작업이 순차적으로 처리되므로 동시에 여러 서버가 같은 데이터를 수정하려는 경합을 방지할 수 있다.

단점으로는 대기 시간이 길어질 수 있어서 대기시간이 중요한 시스템에서는 다른 방법을 사용해야한다.

# 동시성 관련
https://f-lab.kr/insight/concurrency-issues-solutions-20240911

# 분산락에 대한 개념 찾아보기
여러 분산 시스템(다중 서버, 클러스터 등)에서 동시에 자원을 접근하려고 할 때, 동시에 같은 자원에 접근하는 것을 방지하기 위해 사용됩니다.
일반적인 로컬 락과는 달리, 분산 환경에서는 각 서버가 물리적으로 독립되어 있어 여러 프로세스나 서버 간에 자원 접근을 조율하기 위한 별도의 관리 방식이 필요
여러 서버나 프로세스가 동일한 자원을 동시에 수정하거나 접근하지 못하게 하여 데이터 일관성과 무결성을 유지합니다.

## 락 관리 시스템
분산 락을 구현하려면 중앙 관리 시스템이 필요합니다. 주로 Redis, ZooKeeper, etcd와 같은 시스템이 사용됩니다.
예를 들어, Redis는 SETNX 명령을 통해 락을 설정하고, ZooKeeper는 분산 노드에 대한 락 관리 기능을 제공합니다.

### Lettuce, Redisson
Lettuce는 분산락 구현 시 setnx, setex과 같은 명령어를 이용해 지속적으로 Redis에게 락이 해제되었는지 요청을 보내는 스핀락 방식으로 동작합니다. 요청이 많을수록 Redis가 받는 부하는 커지게 됩니다.
이에 비해 Redisson은 Pub/Sub 방식을 이용하기에 락이 해제되면 락을 subscribe 하는 클라이언트는 락이 해제되었다는 신호를 받고 락 획득을 시도하게 됩니다.

## TTL
락을 설정할 때 시간 제한을 설정하여, 서버가 락을 획득한 후 오류로 인해 해제하지 못하는 상황을 방지합니다.
TTL이 지나면 락이 자동으로 해제되어 다른 서버가 접근할 수 있게 됩니다.

## 뮤텍스와 세마포어
분산 락의 방식에는 하나의 서버만 자원을 사용할 수 있는 뮤텍스(Mutex) 방식과 여러 개의 서버가 일정 수의 자원을 공유할 수 있는 세마포어(Semaphore) 방식이 있습니다.

## 데드락 방지
분산 락을 사용할 때 데드락(deadlock)을 방지하기 위한 전략이 필요합니다. 락 해제 시 시간 제한(TTL)을 이용하거나,
락이 걸린 프로세스나 서버가 실패했을 때 다른 서버가 락을 해제하도록 하는 방식이 사용됩니다.

## 활용 예
https://helloworld.kurly.com/blog/distributed-redisson-lock/
https://techblog.woowahan.com/17416/

# 에러 스택 트레이스를 스레드를 새로 만들어서 찍을때랑 아닐때를 비교해서 찍어보기


# nonblocking, blocking, 비동기, 동기
- 동기 : 호출된 작업이 완료될 떄까지 호출자가 기다리는 방식으로 작업이 끝나야 다음 코드가 실행된다. 코드가 순차적으로 진행되어서 이해하기 쉽지만 시간이 오래걸린다.
- 비동기 : 호출된 작업이 완료될때까지 기다리지않고 다른 작업을 진행한다. 작업이 완료되면 콜백 함수나 Future, Promise 를 통해 결과를 받는다. 작업이 병렬적으로 진행되어 시스템 자원을 효율적으로 사용하지만, 흐름이 복잡해진다.
- 블로킹 : 호출된 작업이 완료될때까지 제어권을 가지고 있는다. 현재 실행중인 스레드가 대기상태로 남아있다. 스레드가 작업을 멈추고 기다리기때문에 IO작업에서 블로킹방식으로 하게되면 많은 스레드가 비효율적으로 대기 상태가 될 수 있다. 
- 논블로킹 : 호출된 작업이 작업을 완료하지 않아도 제어권을 넘기고 다른 작업을 수행한다.

- 동기 + 블로킹: 서버는 클라이언트 요청을 받아들일 때, 요청이 완전히 처리될 때까지 기다립니다. 동시에 다른 요청을 처리하지 못합니다. 
- 동기 + 논블로킹: 서버는 요청을 처리하는 동안 다른 요청을 받아들일 수 있습니다. 논블로킹 방식이지만, 요청을 순차적으로 처리하므로 요청 순서를 유지합니다.
- 비동기 + 블로킹: 서버는 요청을 비동기적으로 처리하지만, 요청을 기다리는 동안 작업이 완료될 때까지 스레드가 대기합니다. 자원 낭비가 발생할 수 있습니다.
- 비동기 + 논블로킹: 서버는 요청을 비동기적으로 처리하고, 다른 요청이 오면 즉시 받아들여 병렬로 처리할 수 있습니다. 서버의 응답성이 높아지고 자원 사용이 효율적입니다.

- 동기 vs 비동기: 호출자의 코드 흐름과 작업 완료 대기 여부에 대한 차이입니다.
- 블로킹 vs 논블로킹: 현재 스레드가 작업이 완료될 때까지 대기하는지 여부에 대한 차이입니다.


# time out 의 종류에 따라서 처리해야되는 일이 다르다. 각각 어떻게 처리를 해줘야하는지 찾아보기

### 1. **커넥션 획득 타임아웃 (Connection Acquisition Timeout)**
- **정의**: 사용자가 커넥션 풀에서 커넥션을 요청할 때, 사용 가능한 커넥션이 없을 경우 대기하는 최대 시간을 의미합니다. 설정한 시간 내에 커넥션을 얻지 못하면 타임아웃 예외가 발생합니다.
- **처리 방법**:
    - **타임아웃 시간 조정**: 애플리케이션 부하와 요청 패턴에 맞게 타임아웃 시간을 조정합니다.
    - **풀 크기 조정**: 동시에 사용할 수 있는 커넥션의 수를 늘려서 대기 시간을 줄입니다.
    - **대체 처리**: 커넥션을 얻지 못한 경우 대체 로직을 구현하여 예외 상황에 대한 대처를 할 수 있습니다. 예를 들어, 사용자에게 작업 지연 안내 메시지를 보여주거나, 다른 서비스에 요청을 전달하는 방식을 사용할 수 있습니다.

---

### 2. **커넥션 대기 타임아웃 (Connection Wait Timeout)**
- **정의**: 커넥션이 사용 중일 때 다른 요청이 해당 커넥션이 해제되기를 기다리는 최대 시간을 뜻합니다. 대기 시간 내에 커넥션을 사용할 수 없다면 타임아웃이 발생합니다.
- **처리 방법**:
    - **대기 시간 최적화**: 시스템에서 커넥션이 너무 오래 사용되지 않도록 쿼리 성능을 최적화하고, 커넥션을 필요한 순간에만 획득해 사용 시간을 줄입니다.
    - **타임아웃 설정**: 적절한 대기 시간을 설정하여 시스템 부하를 조절하고, 예기치 않은 타임아웃을 방지합니다.
    - **에러 핸들링**: 대기 타임아웃이 발생할 경우 사용자에게 지연 안내를 표시하거나 재시도 전략을 적용합니다.

---

### 3. **커넥션 유휴 타임아웃 (Connection Idle Timeout)**
- **정의**: 커넥션이 풀에서 대기 상태로 유지될 수 있는 최대 시간을 의미합니다. 이 시간이 지나면 유휴 상태의 커넥션은 풀에서 제거되거나 닫힙니다.
- **처리 방법**:
    - **적절한 유휴 시간 설정**: 유휴 타임아웃을 설정하여 불필요한 커넥션이 오랫동안 유지되는 것을 방지하고, 커넥션 풀의 크기를 효과적으로 관리합니다.
    - **유휴 커넥션 관리**: 주기적으로 유휴 커넥션을 점검하고, 일정 시간 동안 사용되지 않은 커넥션은 자동으로 반환되도록 설정합니다.
    - **재연결**: 유휴 타임아웃이 발생한 후 재연결이 필요한 경우, 커넥션을 다시 생성하도록 재연결 로직을 구현합니다.

---

### 4. **커넥션 생명 주기 타임아웃 (Connection Lifetime Timeout)**
- **정의**: 커넥션 풀에 커넥션이 생성된 후 유지될 수 있는 최대 시간을 설정하는 타임아웃입니다. 일정 시간이 지나면 해당 커넥션은 풀에서 제거되고 새 커넥션으로 교체됩니다.
- **처리 방법**:
    - **최대 생명 주기 설정**: 커넥션의 최대 생명 주기를 설정하여, 오래된 커넥션이 네트워크 장애 등으로 인해 비효율적으로 작동하지 않도록 합니다.
    - **새 커넥션 생성**: 생명 주기가 끝난 커넥션은 새 커넥션으로 대체되므로 시스템 전체 성능 유지에 기여합니다. 생명 주기가 끝난 커넥션은 자동으로 풀에서 제거하도록 설정합니다.
    - **재연결 처리**: 만료된 커넥션을 대체할 새로운 커넥션을 자동으로 생성하도록 커넥션 풀을 구성합니다.

---

### 5. **소켓 타임아웃 (Socket Timeout)**
- **정의**: 커넥션을 통해 데이터베이스에 쿼리를 요청한 후, 응답을 기다리는 시간입니다. 소켓 타임아웃을 통해 요청한 쿼리가 일정 시간 내에 응답하지 않을 경우 예외를 발생시킵니다.
- **처리 방법**:
    - **타임아웃 시간 설정**: 예상되는 응답 시간에 맞춰 적절히 설정하여, 무한 대기 상황을 방지합니다.
    - **쿼리 최적화**: 시간이 오래 걸리는 쿼리를 최적화하거나 인덱스를 활용해 응답 시간을 줄입니다.
    - **재시도 로직**: 소켓 타임아웃이 발생하면 쿼리를 다시 시도하거나 실패 로직을 처리합니다.

---

커넥션 풀의 타임아웃 설정은 시스템의 성능과 안정성을 직접적으로 좌우하기 때문에, 예상되는 트래픽과 애플리케이션 특성에 맞게 신중하게 설정해야 합니다.

---

### 1. **작업 타임아웃 (Task Timeout)**
- **정의**: 비동기 작업, 배치 작업, 예약 작업 등 특정 작업이 정해진 시간 내에 완료되지 않을 때 발생하는 타임아웃입니다.
- **예시**: 대용량 데이터 처리 작업이 지연될 경우 작업 타임아웃이 발생할 수 있습니다.
- **처리 방법**:
    - **작업을 소분화**: 대규모 작업을 작은 단위로 분리하여 각 작업의 타임아웃을 관리합니다.
    - **모니터링 및 알림**: 작업 타임아웃 발생 시 관리자에게 알림을 보내 원인을 분석할 수 있도록 합니다.
    - **작업 재시도 및 중단**: 일정 횟수만큼 재시도 후 작업을 중단하거나 대체 로직으로 전환할 수 있습니다.

---

### 2. **API 호출 타임아웃 (API Call Timeout)**
- **정의**: 외부 API나 타 시스템의 서비스에 요청을 보냈을 때, 응답이 설정된 시간 내에 도착하지 않으면 발생하는 타임아웃입니다.
- **예시**: 외부 결제 서비스나 인증 서버에서 응답이 지연될 때 발생할 수 있습니다.
- **처리 방법**:
    - **타임아웃 시간 설정**: 외부 API의 평균 응답 시간에 맞춰 적절한 타임아웃을 설정합니다.
    - **백오프 전략 및 재시도**: API 호출이 실패할 경우 점진적인 대기 시간을 적용해 재시도를 시도합니다.
    - **회로 차단기(Circuit Breaker) 패턴**: 연속적인 타임아웃이 발생할 경우 API 호출을 일시적으로 중단하고 시스템을 보호합니다.

---

### 3. **유휴 타임아웃 (Idle Timeout)**
- **정의**: 시스템 리소스가 일정 시간 동안 사용되지 않을 경우 발생하는 타임아웃입니다. DB 커넥션뿐만 아니라 웹소켓이나 세션 관리에서도 적용될 수 있습니다.
- **예시**: 사용자가 웹 애플리케이션에서 일정 시간 동안 활동하지 않으면 세션이 만료되는 경우가 이에 해당합니다.
- **처리 방법**:
    - **유휴 상태 관리**: 유휴 시간을 설정하고, 일정 시간 동안 활동이 없는 리소스는 자동으로 정리되도록 설정합니다.
    - **주기적 체크**: 유휴 상태의 리소스를 주기적으로 확인하여 불필요한 리소스를 종료하거나 풀에서 제거합니다.
    - **세션 만료 안내**: 사용자 세션 타임아웃이 발생하면 만료 안내를 통해 재로그인을 유도합니다.

---

### 4. **응답 타임아웃 (Response Timeout)**
- **정의**: 클라이언트가 서버로부터 응답을 받기까지 기다릴 수 있는 최대 시간을 의미합니다.
- **예시**: API 응답이 너무 오래 걸릴 경우, 클라이언트가 응답을 기다리지 않고 타임아웃을 발생시킵니다.
- **처리 방법**:
    - **짧은 타임아웃 설정**: API 응답이 길어질 경우 적절한 타임아웃을 설정해 무한 대기를 방지합니다.
    - **부분 응답 제공**: 대용량 응답의 경우 스트리밍 방식으로 부분적으로 제공하여 사용자 대기 시간을 줄입니다.
    - **비동기화**: 응답 지연이 예상되는 경우 비동기 처리로 전환해 대기 없이 후속 작업을 진행합니다.

---

### 5. **데드락 타임아웃 (Deadlock Timeout)**
- **정의**: 데이터베이스나 동시성 작업에서 서로 잠금을 걸고 있는 상태가 풀리지 않을 때 발생합니다. 데드락 타임아웃은 일정 시간 이후 시스템이 데드락을 자동으로 해제하도록 합니다.
- **예시**: 두 트랜잭션이 서로의 리소스를 요청하면서 교착 상태가 발생할 수 있습니다.
- **처리 방법**:
    - **타임아웃 감지 및 해제**: 데드락이 발생하면 시스템이 타임아웃을 감지해 관련 작업을 취소합니다.
    - **트랜잭션 분리**: 하나의 트랜잭션에서 많은 리소스를 잠그는 것을 피하고, 가능한 한 작은 단위로 분리합니다.
    - **락 회피 전략**: 교착 상태를 피할 수 있는 알고리즘을 적용해 순차적으로 락을 해제합니다.

---

### 6. **세션 타임아웃 (Session Timeout)**
- **정의**: 사용자 세션이 일정 시간 동안 활동이 없으면 만료되도록 설정하는 타임아웃입니다. 보안 강화를 위해 주로 사용됩니다.
- **예시**: 사용자가 로그인 후 일정 시간 동안 활동이 없으면 자동 로그아웃되는 경우입니다.
- **처리 방법**:
    - **세션 만료 시간 설정**: 보안 요구에 맞춰 적절한 세션 만료 시간을 설정합니다.
    - **사용자 알림**: 세션이 만료되기 전에 사용자에게 경고 알림을 제공해 세션을 연장할 수 있도록 합니다.
    - **재로그인**: 세션이 만료된 경우 자동 로그아웃하고 재로그인을 유도합니다.

---


# docker, container 에 대해서 찾아보기 (천천히)


# 메서드의 재정의를 막는 이유?
## 캡슐화를 깨트린다.
- 상위 클래스는 릴리스마다 내부 구현이 달라질 수 있으며, 그 여파로 코드 한 줄 건드리지 않은 하위 클래스가 오동작할 수 있다.
- 하위 클래스에서는 접근할 수 없는 private 필드를 써야 하는 상황이라면 이 방식으로는 구현자체가 불가능
- 만약 상위 클래스에 새로운 메서드가 추가된다면, 새롭게 추가된 메서드를 통해서 허용되지 않은 동작을 수행할 수 있게 될 수도 있다.
## 해결방법
- 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하면 된다. -> 컴포지션 방식
- 새 클래스의 인스턴스 메서드들은 (private 필드로 참조하는) 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환한다.
- 
