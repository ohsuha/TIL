# GC들에서 영역을 나눠놓는 이유에 대해서 찾아보기
young 영역 : 새롭게 생성된 객체가 저장되는 곳으로 이곳에 있는 객체는 짧은 시간 안에 가비지로 변활 확률이 높다.
따라서 자주 가비지 컬렉션이 일어난다.
짧은 시간 동안 많은 객체가 생성되고 소멸되므로, young 영역에서는 자주 GC를 수행해도 큰 성능 저하가 없습니다. 이 영역에서의 Minor GC는 비교적 빠르고 가벼운 작업
Minor GC는 주로 young 영역에서만 일어나기 때문에 메모리 정리 시간이 짧고, 응용 프로그램이 중단되는 시간(stop-the-world 시간)이 짧습니다.


old 영역 : 이 영역의 객체들은 비교적 오래 유지되고 가비지 컬렉션 빈도가 낮다.
오래 지속되는 객체이므로 빈번히 GC를 할 필요가 없다.
Major GC는 더 많은 리소스를 소비하고 오래 걸리므로 자주 발생하지 않도록 하여 전체 성능에 미치는 영향을 최소화하려는 것입니다.

## 왜 올드 영역의 객체들이 더 리소스를 많이 소비할까?
1. old 영역은 영역보다 크기 때문에 전체 메모리를 스캔하고 정리하는데 걸리는 시간이 더 오래 걸림
2. 올드 영역의 객체들은 큰 메모리 공간을 차지하는 경우도 있어 검사하고 처리 해야하는 양자체가 많음
3. 올드 영역은 복잡한 참조 관계를 가질 가능성이 높다. 이 참조 추적에 추가적인 비용이 발생
4. 올드 영역은 메모리 파편화가 발생할 가능성이 커서 압축작업을 수행하는데 이때 많은 시간이 소요된다.

# 서버가 여러대인 상황에서 동시성을 관리하는 방법
## 분산 락 (Distributed lock)
여러 서버에서 동시에 같은 리소스에 접근할 때, 분산 락을 사용하여 경합 조건을 방지할 수 있습니다. 이를 통해 한 번에 하나의 서버만 특정 자원을 수정하거나 접근하도록 제한할 수 있습니다.
- Redis 기반 분산 락: Redis의 SETNX(set if not exists)와 같은 명령어를 사용해 락을 걸 수 있습니다. Redis는 빠르고 확장성이 좋은 인메모리 데이터베이스로, 주로 분산 락을 구현하는 데 자주 사용됩니다. Redlock 알고리즘도 Redis 기반으로 분산 환경에서 안전하게 락을 관리하는 방식입니다.
- Zookeeper: Zookeeper는 분산 시스템에서 동기화와 락을 관리할 수 있는 서비스입니다. 트랜잭션성 높은 락을 제공하여 여러 서버 간의 동시성 문제를 해결하는 데 유용합니다.
## 메시지 큐
여러 서버에서 동시에 작업을 처리할 때, 메시지 큐를 사용하여 작업을 순차적으로 처리할 수 있습니다. 이를 통해 동시성 문제를 방지하고, 작업 처리를 분산시킬 수 있습니다.
메시지 큐를 사용해 작업 처리를 분산하고 순서를 보장
- kafaka
- RMQ
## 샤딩(Sharding)과 파티셔닝(Partitioning)
샤딩 또는 파티셔닝을 사용하여 데이터를 여러 서버에 분산,  이를 통해 각 서버는 특정 데이터만 처리하게 되므로, 경합을 줄일 수 있습니다.
- 샤딩: 데이터를 특정 기준에 따라 여러 서버에 나누어 저장하고 처리하는 방식입니다. 예를 들어, 사용자의 ID에 따라 데이터베이스 샤드를 나누면, 각 서버는 특정 범위의 사용자 데이터만 처리하므로 동시성 문제가 줄어듭니다.
## 트랜잭션 관리
- SAGA 패턴: 분산 트랜잭션 대신 마이크로서비스에서 많이 사용하는 패턴으로, 각 서비스가 자체적으로 트랜잭션을 관리하고 문제가 발생하면 보상 작업을 통해 상태를 롤백하는 방식입니다. 트랜잭션을 작게 나누어 동시성 문제를 해결할 수 있습니다.
- 분산 트랜잭션: 여러 서버가 동일한 트랜잭션 내에서 동작하도록 하여 데이터의 일관성을 보장하는 방법입니다. 주로 2PC(Two-Phase Commit) 알고리즘이 사용됩니다. 하지만 이 방식은 네트워크 및 트랜잭션 매니저에 대한 의존도가 높고, 성능에 영향을 미칠 수 있습니다.

# nonblocking api 디버깅 하는 것의 어려움
- Non-blocking API는 비동기적으로 작동하므로, 요청과 응답 사이에 시간 차이가 발생합니다. 이로 인해 일반적인 동기적 디버깅 방법이 적용되지 않으며, 문제의 원인을 추적하기 어려워질 수 있습니다.
- 비동기 코드에서는 여러 콜백이 중첩되기 때문에 코드의 가독성이 떨어지고, 오류 발생 지점을 찾기 힘들어질 수 있습니다.
- 비동기 코드에서 발생하는 예외는 일반적인 try-catch 구문으로 처리하기 어렵습니다. Promise나 Future를 사용하는 경우, 예외가 적절히 처리되지 않으면 애플리케이션의 전체 흐름이 영향을 받을 수 있습니다.
- Non-blocking API는 여러 요청이 동시에 처리될 수 있으므로, 각 요청의 상태를 관리하기 어렵습니다. 상태가 서로 영향을 주거나 변경될 수 있어 디버깅이 복잡해질 수 있습니다.
- 비동기 프로세스에서는 로깅이 어떤 요청과 관련된 로그인지 명확하게 연결짓기 어렵습니다. 로그의 순서가 비동기적으로 처리되기 때문에 문제를 재현하기 힘들 수 있습니다.
## 비동기 디버깅을 지원하는 툴
Java CompletableFuture

Future는 외부에서 작업을 완료시킬 수 없고, 작업 완료는 오직 get 호출 시에 타임아웃으로만 가능하다. 또한 비동기 작업의 응답에 추가 작업을 하려면 get을 호출해야 하는데, get은 블로킹 호출이므로 좋지 않다. 또한 여러 Future들을 조합할 수도 없으며, 예외가 발생한 경우에 이를 위한 예외처리도 불가능하다. 그래서 Java8에서는 이러한 문제를 모두 해결한 CompletableFuture가 등장하게 되었다.

https://mangkyu.tistory.com/263
https://dev-coco.tistory.com/185
### Future 와 비동기, nonblocking 에 대해서 더 찾아봐야겠다.

# 외부 서버와 연결을 맺을 때 timeout 관리
타임아웃을 설정해야 하는 이유
1. 안정성: 외부 서버가 응답하지 않을 때 시스템이 무기한 대기하지 않도록 방지. 
2. 자원 관리: 네트워크 연결과 스레드를 오랫동안 대기시키지 않고 적절히 해제. 
3. 장애 복구: 타임아웃이 발생하면 재시도나 예외 처리를 통해 다른 서버로 요청을 보내거나 장애를 해결할 수 있는 방법을 제공.

# C1, C2 컴파일러
C1과 C2 컴파일러는 자바 가상 머신(JVM)에서 자바 바이트코드를 네이티브 코드로 변환하는 JIT(Just-In-Time) 컴파일러의 두 가지 레벨이다.
서로 다른 컴파일 전략을 사용하여 자바 애플리케이션의 성능을 개선한다.

## C1
- 빠른 컴파일 시간에 중점을 둬서 최소한의 최적화를 수행한다.
- 성능보다는 빠르게 컴파일을 완료하는 것이 목표
- Client 모드로 실행되는 JVM에서 실행된다.
- CPU 사용량이 적고 응답성을 중요시하는 애플리케이션에 적합하다.
- 최적화 정도는 낮지만, 즉시 실행되는데 중점

## C2
- 복잡한 최적화를 수행하여 최종 성능을 극대화하는 데 중점을 둔다.
- 자주 실행되는 코드(핫스팟)을 식별하고 고도의 최적화를 적용하여 네이티브 코드로 컴파일한다.
- Sever 모드로 실행되는 JVM에서 사용되며, 더 긴 컴파일 시간을 허용하고 성능을 극대화 하려는 애플리케이션에 적합하다.
- 애플리케이션의 최대 성능을 보장하지만, 컴파일 속도는 느릴 수 있다.

## Tiered Compilation(계층형 컴파일)
C1, C2 를 함께 사용하는 컴파일이다.
먼저 C1 컴파일러가 빠르게 코드 실행을 시작하고,  이후에 C2 컴파일러가 더 복잡핳ㄴ 최적화를 수행해 성능을 높인다.

# heap dump
Java 애플리케이션의 메모리 상태를 저장한 파일로, 힙 메모리에 할당된 객체와 그들의 참조 상태를 기록한 스냅샷입니다. 주로 애플리케이션의 메모리 문제를 분석할 때 사용

- OOM 발생시 어떤 객체들이 메모리를 많이 차지하고 있는지 보기 위해서
- 메모리 누수를 찾아내기 위해서
- Heap Dump 파일은 .hprof 형식으로 저장되며, 이를 분석하기 위해 Eclipse MAT (Memory Analyzer Tool) 또는 VisualVM 같은 도구를 사용
- MAT(Memory Analyzer, https://www.eclipse.org/mat/)다. MAT는 자바 힙 분석을 위한 풍부한 기능을 제공하여 메모리 누수 및 메모리 소비 감축요소를 찾을 수 있도록 돕는다.

상황이 발생했을 때 힙덤프를 생성하는 선택사항(-XX:+HeapDumpOnOutOfMemoryError)과 위치를 지정하는 선택사항(`-XX:HeapDumpPath=/var/log `)를 추가한다. 이렇게 설정해놓으면 OutOfMemoryError가 발생했을 때 java_pid{pid}.hprof파일이 지정된 위치에 생성된다.

```text
//pid가 1234인 자바 프로세스의 heapdump 파일을 대상 디렉토리에 생성
jmap -dump:format=b,file=/tmp/heapdump.hprof 1234
```

# heap memory 늘리는 옵션
java -Xms512m -Xmx2g -jar yourapp.jar
-Xms512m은 초기 힙 메모리 크기를 512MB로 설정합니다.
-Xmx2g은 최대 힙 메모리 크기를 2GB로 설정합니다.