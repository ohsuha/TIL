# APM에 대해서 찾아보기
## 종류
- DB 성능 관리 : 개발자가 작성한 SQL 의 튜닝 및 DBMS 소프트 웨어 병목 현상등을 모니터링
- 애플리케이션 성능 관리 : 일반적으로 의미하는 APM 솔루션, WAS 등을 대상으로 모니터링, 언어별로 다양한 솔루션이 존재한다.
- End to End 최종 사용자 성능 관리 : EUM, E2E 등으로 불림, 네트워크 기반 기술. 

애플리케이션 성능 관리(Application Performance Monitoring, 이하 APM)는 마치 숙련된 의사가 환자의 건강 상태를 체크하듯,
애플리케이션의 성능을 모니터링하고, 장애를 빠르게 감지하여 대응할 수 있도록 돕는  일련의 시스템 관리 체계를 의미합니다.
즉, 기업 비즈니스 애플리케이션의 성능을 모니터링하고 분석하여 발생할 수 있는 성능 저하, 오류, 시스템 장애 등의 문제를 신속하게 진단하고 해결하여,
기업 비즈니스 시스템의 성능을 안정적인 상태로 유지하는 것이 APM의 주요 역할입니다.

https://jennifersoft.com/ko/product/apm/features/


# 서버를 모니터링 하는 것과 관련해 찾아보기
1. 서버 자원 모니터링 : CPU, 메모리, 디스크 사용량 등을 체크하고 프로세스 상태를 모니터링
2. 어플리케이션 모니터링 : 서버에서 실행중인 애플리케이션의 상태와 성능을 모니터링, 응답시간, 트랜잭션, 에러로그, 서비스 가용성 모니터링
3. 네트워크 모니터링 : 서버가 네트워크와 상호작용하는 상태에 대한 모니터링, 패킷 손실, 지연 시간, 네트워크 트래픽, 방화벽 상태를 모니터링한다.
4. 로그 모니터링 : 서버와 애플리케이션에서 생성된 로그 파일을 시시간으로 분석하여 문제를 감지하고 경고한다. 
5. 보안 모니터링 : 비정장적인 액세스 시도 감지, 로그인 시도, 웹 서버의 보안 인증서 만료 등에 대한 확인
6. 데이터 베이스 모니터링 : 쿼리 성능, 연결 풀 상태, 디비 크기 및 사용량 등을 추적
7. 서비스 가용성 모니터링 : 서버에서 실행 중인 서비스의 가용성을 모니터링한다. 서버에서 실행 중인 다양한 서비스가 중단 없이 실행 중인지 모니터링

## 대표적인 서버 모니터링 도구
Nagios: 오픈 소스 기반의 서버 모니터링 도구로, 네트워크 및 서버 상태를 실시간으로 추적하고 문제 발생 시 알림을 제공합니다.

Zabbix: 서버 자원 모니터링과 네트워크 모니터링에 강력한 오픈 소스 솔루션.

Prometheus: 타임 시리즈 기반 모니터링 시스템으로, 서버 성능 및 자원 모니터링에 자주 사용됩니다.

Grafana: Prometheus와 함께 사용하여 데이터를 시각화하는 대시보드를 제공하는 도구입니다.

New Relic: 클라우드 및 서버 모니터링을 위한 상용 도구로, 애플리케이션 성능 및 서버 상태를 실시간으로 모니터링할 수 있습니다.

Datadog: 클라우드 기반 서버 모니터링 도구로, 인프라, 애플리케이션, 로그를 통합적으로 모니터링할 수 있습니다.


# G1GC를 포함한 GC 내용 찾아보기
- 시리얼 콜렉터
- 병렬 콜렉터
- CMS 콜렉터
- G1 콜렉터
- ZGC

---

# static을 사용할 때 주의해야할 점
- 전역 변수는 코드 어디에서나 접근할 수 있어서 전역 변수이고 메서드들이 공유해 사용하기 때문에 공유 변수라고도 한다.
- 다른 메서드들에 의해 전역 변수에 다른 값이 저장되면 코드를 추적해 들어가야만 그 값과 값이 변한 이유를 파악할 수 있다.
- 따라서 전역 변수는 읽기 전용으로 값을 공유해서 전역 상수로 쓰는것이 추천된다.
- 스레드는 다른 스레드의 스택 영역에는 접근할 수 없지만 스태틱, 힙 영역은 공유해서 사용한다.
- 멀티 스레드에서 전역 변수를 사용해 수정할 수 있게 되면, 모든 스레드가 돌아가면서 전역 변수를 수정할 수 있기 때문에 예상치 못한 결과가 나오게 된다.

---

# 많은 단점에도 불구하고 reflection을 사용하는 이유?
리플렉션은 클래스가 제공하는 다양한 정보들을 동적으로 분석하고 사용하는 기능이다.
프로그램 실행 중에 클래스, 메서드, 필드의 정보를 얻거나 새로운 객체를 생성, 메소드 호출이 가능하다.

- private 접근 제어자에도 접근해서 값을 변경할 수 있다.
- 성능이 느려진다.
- 컴파일 에러가 뜨지 않는다.

이런 단점들에도 불구하고 사용하는데 왜 쓰는걸까?

1. 일반적인 비즈니스 로직에는 사용하지 않고 라이브러리나 테스트코드에서 사용한다.
2. 리플렉션을 활용해 어떤 객체를 받아서 필드값을 조회한 다음 Null 이면 기본 값을 설정해 주는 식으로,
여러 객체에 공통적으로 기본값을 넣어주는 등의 기존 코드로 해결하기 어려운 공통 문제를 손쉽게 처리할 수 있게 도와준다.
객체를 직렬화하거나 역직렬화 하는것도 이런 예시가 될 수 있다. 객체의 구조를 미리 알지 않아도 런타임에 동적으로 필드와 메서드에 접근할 수 있고 프라이빗값도 접근할 수 있어 자유롭게 직렬화가 가능하다. 
3. Transactional 애너테이션은 placeOrder 메서드가 트랜잭션 범위 내에서 실행되도록 만듭니다. Spring은 리플렉션을 사용해 OrderService 클래스의 메서드에 지정된 애너테이션을 스캔하고, 트랜잭션 설정을 동적으로 적용합니다.
4. 이름만 가지고 객체 생성, 메소드 실행이 가능하므로 서블릿에서는 URL 요청 경로를 가지고 경로와 메소드이름이 맞는지 체크해서 invoke 를 통해 동적으로 호출할 수 있다.
5. 스프링에서는 service 에 repository 같은 것을 의존할때 리플렉션을 사용해 repository 객체를 service 의 repository 필드에 주입할 수 있다. 

즉 컴파일 시점에는 알 수 없는 클래스, 메서드, 필드에 동적으로 접근할 수 있다.
직렬화,역직렬화 같은 여러 객체의 공통문제를 손쉽게 처리할 수 있다.
프레임워크에서 리플렉션을 활용하여 개발자에 편리한 기능을 제공할 수 있다.(의존성 주입, AOP, 어노테이션)

-----

# synchronized가 어떻게 한번에 하나의 thread 실행을 보장하는지
각 객체는 내부적으로 모니터라는 동기화 메커니즘을 가지고 있고 모니터는 객체에 대한 접근을 관리한다.
synchronized 를 사용하면 모니터에 접근하게 되는데 모니터에 접근하려면 일단 락을 획득해야한다.
다른 스레드가 락을 가지고 있다면 해당 스레드는 먼저 모니터에 접근한 스레드의 락이 해제될 때까지 대기하게된다.
예를들어 A 클래스의 a 메서드가 싱크로나이즈드로 만들어졌다면, 여러 스레드들은 먼저 A 객체의 락을 획득해야하고, 동시에 한 스레드만 a를 실행할 수있다.

----

# java에서 synchronized 키워드 말고 동시성을 관리하는 방법에는 또 뭐가 있을까?
## ReentrantLock Lock 과 Condition
JDK 1.5 에서 추가된 기능이다. 재진입 가능한 락을 구현, 같은 스레드가 이미 획득한 락을 다시 획득할 수 있다.
lock() 으로 락을 획득하고 unlock()으로 락을 해제한다.
명시적으로 락을 제어할 수 있고 락을 생성할때 공정성을 설정할 수 있다. (생성자의 매개변수를 true 로 주면 가장 오래 기다린 스레드가 락을 가져간다. -> 누가 오래기다렸는지 체크해야하므로 성능은 떨어진다.)

## ReentrantReadWriteLock
읽기에는 공유적이고, 쓰기에는 배타적인 락.
읽기를 위한 lock 과 쓰기를 위한 lock 을 제공한다.
읽기 락이 걸려있으면 다른 스레드가 읽기 락을 중복해서 걸고 읽기를 수행할 수 있다. 읽기는 내용을 변겨하지 않으므로 동시에 여러 스레드가 접근해도 문제 되지 않기 때문이다.
반면 읽기 락이 걸린 상태에서는 쓰기 락을 거는 것은 허용되지 않는다.

## stampedLock
ReentrantReadWriteLock 에 낙관적인 lock의 기능을 추가한 락.
락을 걸거나 해지할 때 스탬프(long 타입의 정수값)을 사용하여 읽기 쓰기 락 외에 낙관적 읽기를 추가했다.
읽기 락이 걸려있으면 쓰기 락을 얻기 까지 읽기 락이 풀리기를 기다려야하는데, 낙관적 읽기 락은 쓰기 락에 의해 바로 풀린다.
무조건 읽기 락을 걸지 않고 쓰기와 읽기가 충돌할 떄만 쓰기가 끝난 후에 읽기락을 새로 거는 것이다.

## tryLock()
다른 스레드에 의해 lock 이 걸려있으면 lock을 얻으려고 기다리지 않거나 지정된 시간 만큼만 기다린다.
lock()은 락을 얻을때까지 스레드를 블락시키므로 응답성이 나빠질 수 있는데 tryLock()을 통해 지정된 시간 동안 lock()을 얻지 못하면 다시 작업을 시도할지, 포기할지 결정할 수 있게 하는 것이 좋다.

## Condition
wait(), notify() 는 스레드를 구분할 수 없는데 Lock 의 Condition 을 사용하면 condition 의 await(), signal()을 통해 wait(), notify()를 대신해 사용할 수 있다.
대기와 통지의 대상이 명확히 구분된다.

## Concurrent Collections
java.util.concurrent 패키지에 있는 ConcurrentHashMap, CopyOnWriteArrayList, BlockingQueue 와 같은 동시성을 관리하는 컬렉션들이있다.


---

# thread와 IO 작업의 관계
프로세스마다 하나의 스레드는 기본으로 가지고 있다.
스레드는 프로그램의 코드를 한줄 한줄 실행하는 역할을 하고 이 역할을 하기위해서는 스레드가 CPU를 써야한다.
스레드는 IO 작업(다른 장치에 일을 맡기는 행위)를 하게 되면 대기 시간이 발생한다.
이 대기시간은 DB에 작업을 요청하고 기다리고, 네트워크로 전송하고 응답 기다리고, 파일 복사하는 등의 작업이며 CPU를 사용하지 않는다.
그 동안 이 스레드가 점유한 CPU는 대기를 기다리느라 놀고있는 상태이다. 뒤에 처리해야할 다른 요청이 많은데도 이 대기를 기다리느라 제대로 처리하지 못한다.
따라서 이럴때는 멀테스레드를 이용해 대기가 발생하는 스레드를 대기 큐에 넣어 놓고 다른 스레드부터 CPU를 사용하게 해주는게 더 효율적이다.

스레드의 숫자는 CPU-바운드가 많은가, IO-바운드가 많은가에 따라 달라질 수 있다.
CPU를 더 많이 쓰는 작업이라면, CPU 코어수만큼 또는 그보다 하나정도 많은것이 좋다.
IO바운드일때느네 스레드가 중간중간 많이 쉬게 된다. CPU코어보다 훨씬 많은 수를 잡아야한다.
이 스레드들이 모두 CPU를 사용하는게 아니므로 CPU가 놀게 하지 않기 위해 스레드가 많아야 한다.

--- 
# IO 에서 병목이 발생하는 원인
- 여러 프로세스나 스레드가 동시에 같은 파일에 접근하려고 하면 락(lock)이 걸려 병목이 발생할 수 있습니다.
- 출력 장치의 동작 속도가 CPU와 메모리 같은 다른 컴퓨터 구성 요소에 비해 훨씬 느리기 때문

## 병목 해결 방법
비동기 I/O 사용: 비동기 I/O는 I/O 작업이 완료될 때까지 스레드를 대기시키지 않으므로, 동기 I/O에 비해 병목을 줄일 수 있습니다.
캐싱 활용: 자주 사용하는 데이터를 메모리나 캐시에 저장하면, I/O 작업을 줄여 병목을 완화할 수 있습니다.
하드웨어 업그레이드: 느린 하드 디스크를 SSD로 교체하거나, 네트워크 장비의 성능을 개선하는 것이 도움이 됩니다.
스케줄링 최적화: 운영체제나 데이터베이스의 스케줄링 및 우선순위 설정을 통해 I/O 요청을 효율적으로 처리할 수 있습니다.
멀티스레드 및 스레드풀 활용: 멀티스레드로 I/O 작업을 분산 처리하거나, 적절한 크기의 스레드풀을 사용하여 처리 병목을 완화할 수 있습니다.

--- 

# System.out.println()와 logger의 성능 차이
## print
- 출력이 즉시 콘솔에 출력되며 I/O 작업. 블로킹 방식으로 모든 출력이 완료될 때까지 해당 스레드는 대기
- 콘솔에 직접 데이터를 출력, 바로바로 처리됨
- 여러 스레드에서 동시에 호출하면 동시 접근으로 인해 경합이 발생할 수 있고 전체 성능 저하
## logger
- 로그를 즉시 출력하지 않고 버퍼에 모아 둔 다음, 비동기적으로 출력하는 방식으로 처리할 수 있다.
- 로그 메시지를 내부적으로 버퍼링하여 IO 작업을 최적화하고 병목을 줄일 수 있다.
- 메시지 포맷팅을 미리 하지 않다가 실제 로그 레벨에 맞는 메시지가 출력될 때만 포맷팅을 하는 lazy evaluation 방식을 사용한다.

## 버퍼링이란?
데이터를 메모리상의 임시 공간에 저장한 후 일정 크기의 데이터가 쌓이면 한번에 처리하는 방식으로 매번 IO작업으로 출력하면 느리기 때문에 일정량 데이터를
모아둔 후 한번에 처리한다. 

성능 측면에서: System.out.println()은 동기적이고 매번 I/O 작업을 수행하므로 성능이 떨어집니다. 반면, 로거는 비동기 처리, 버퍼링 등의 성능 최적화 기능을 제공하므로 성능이 더 우수합니다.
유지보수 측면에서: 로거는 로그 레벨 제어, 다중 출력 옵션, 확장성 등을 제공하여 대규모 애플리케이션에서 효율적이고 관리 가능한 로그 시스템을 구축할 수 있습니다. System.out.println()은 이런 기능이 없고, 단순히 콘솔에 출력하는 역할만 하기 때문에 복잡한 시스템에는 적합하지 않습니다.
로깅 제어와 확장성 측면에서: 로거는 로그 레벨을 기반으로 로그를 필터링하고, 로그를 다양한 방식으로 저장하거나 전송할 수 있어 유연성이 매우 높습니다.
---

# nonblocking api 디버깅 하는 것의 어려움

## 그럼에도 nonblocking api 를 사용하는 이유

---

# 새롭게 connection을 맺는게 오래 걸리는 이유
커넥션을 생성할때마다 인증, 세션초기화, 핸드셰이크 등의 과정이 발생하고 이 과정들은 오래 걸린다.
1. 디비에 연결하기 위해서는 사용자 ID 와 비번을 검증해야하는데 이 검증과정에 대한 시간 소요
2. 커넥션이 설정되면 디비는 해당 세션에 대한 초기변수를 설정해야하는데 이 초기화 시간이 소요
3. TCP 연결을 설정할때 패킷을 주고받으며 연결을 설정하는데 이 과정이 추가로 발생

-----
# close를 호출하지 않으면 어떤 이슈가 발생할 수 있는지?
디비 서버에 연결할 수 있는 최대 connection 수가 있는데 이를 낭비하게 되면 커넥션이 고갈될 수 있다.
커넥션이 많아지면 디비 서버가 더 많은 커넥션을 관리해야하므로 CPU, 메모리 자원을 낭비해 응답 시간이 느려질 수 있다.
커넥션을 유지하기 위해 데이터베이스는 네트워크 소켓을 관리해야 합니다. 각 소켓은 커넥션이 존재하는 동안 네트워크 자원을 사용하며, 이로 인해 시스템 오버헤드가 발생

## 커넥션풀은 왜 close 를 안하고 재사용함?
일반적으로 데이터베이스 커넥션에서 close() 메서드는 커넥션을 종료하고 해당 자원을 해제하는 역할을 합니다.
그러나 커넥션 풀에서는 close() 메서드를 호출할 때 실제로 커넥션을 종료하지 않고, 해당 커넥션을 풀로 반환하는 방식으로 작동합니다.
즉, 커넥션 풀은 커넥션을 "종료"하는 대신 "해제"하는 것입니다.
풀은 커넥션을 사용할 때와 반환할 때 적절한 초기화 및 검증 작업을 수행하여 불필요한 리소스 소모를 방지합니다.
## 커넥션 종료와 해제의 차이
- 커넥션을 종료하는 것은 해당 커넥션을 완전히 닫고, 데이터베이스와의 연결을 끊는 것을 의미
- 커넥션 풀에서 커넥션을 해제하는 것은 해당 커넥션을 종료하지 않고, 풀에 반환하는 것을 의미. 커넥션을 해제하면 커넥션은 여전히 데이터베이스와 연결된 상태를 유지하지만, 애플리케이션에서는 해당 커넥션을 더 이상 사용하지 않게 됩니다. 대기 상태로 전환

----

# RestTemplate를 왜 빈으로 등록하는게 좋을지?
빈으로 등록하게 되면 스프링이 싱글톤 패턴을 통해 하나의 인스턴스만 만들어 주므로 자원 낭비를 줄이고 여러 요청에 대해 동일한 객체를 재사용할 수 있다.
이미 생성된 객체를 재사용
빈으로 등록하면 HTTP 요청에 대한 공통 설정을 한 곳에서 관리할 수 있다.
의존성 주입을 통해 쉽게 주입받을 수 있어서 구현체를 교체하거나 mock 객체를 만들기 편리하다 -> 의존성을 명확하게 관리할 수 있다.

---

# 외부 서버에 요청하는 내용에 대해서 테스트를 하는 방법
1. Mocking : 외부 서버의 통신을 모방해 실제 네트워크 요청 없이 테스트를 수행 HTTP 요청을 mock 처리 하거나 WireMock 라이브러리로 외부 서버의 응답을 모킹할 수 있다.
2. 실제 서버 호출 : @SpringBootTest 와 함께 RestTamplate, WebTestClient 를 이용하여 요청을 테스트 할 수 있다. 