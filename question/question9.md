# APM에 대해서 찾아보기
# 서버를 모니터링 하는 것과 관련해 찾아보기
# G1GC를 포함한 GC 내용 찾아보기
- 시리얼 콜렉터
- 병렬 콜렉터
- CMS 콜렉터
- G1 콜렉터
- ZGC

---

# static을 사용할 때 주의해야할 점
- 전역 변수는 코드 어디에서나 접근할 수 있어서 전역 변수이고 메서드들이 공유해 사용하기 때문에 공유 변수라고도 한다.
- 다른 메서드들에 의해 전역 변수에 다른 값이 저장되면 코드를 추적해 들어가야만 그 값과 값이 변한 이유를 파악할 수 있다.
- 따라서 전역 변수는 읽기 전용으로 값을 공유해서 전역 상수로 쓰는것이 추천된다.
- 스레드는 다른 스레드의 스택 영역에는 접근할 수 없지만 스태틱, 힙 영역은 공유해서 사용한다.
- 멀티 스레드에서 전역 변수를 사용해 수정할 수 있게 되면, 모든 스레드가 돌아가면서 전역 변수를 수정할 수 있기 때문에 예상치 못한 결과가 나오게 된다.

---

# 많은 단점에도 불구하고 reflection을 사용하는 이유?
리플렉션은 클래스가 제공하는 다양한 정보들을 동적으로 분석하고 사용하는 기능이다.
프로그램 실행 중에 클래스, 메서드, 필드의 정보를 얻거나 새로운 객체를 생성, 메소드 호출이 가능하다.

- private 접근 제어자에도 접근해서 값을 변경할 수 있다.
- 성능이 느려진다.
- 컴파일 에러가 뜨지 않는다.

이런 단점들에도 불구하고 사용하는데 왜 쓰는걸까?

1. 일반적인 비즈니스 로직에는 사용하지 않고 라이브러리나 테스트코드에서 사용한다.
2. 리플렉션을 활용해 어떤 객체를 받아서 필드값을 조회한 다음 Null 이면 기본 값을 설정해 주는 식으로,
여러 객체에 공통적으로 기본값을 넣어주는 등의 기존 코드로 해결하기 어려운 공통 문제를 손쉽게 처리할 수 있게 도와준다.
객체를 직렬화하거나 역직렬화 하는것도 이런 예시가 될 수 있다. 객체의 구조를 미리 알지 않아도 런타임에 동적으로 필드와 메서드에 접근할 수 있고 프라이빗값도 접근할 수 있어 자유롭게 직렬화가 가능하다. 
3. Transactional 애너테이션은 placeOrder 메서드가 트랜잭션 범위 내에서 실행되도록 만듭니다. Spring은 리플렉션을 사용해 OrderService 클래스의 메서드에 지정된 애너테이션을 스캔하고, 트랜잭션 설정을 동적으로 적용합니다.
4. 이름만 가지고 객체 생성, 메소드 실행이 가능하므로 서블릿에서는 URL 요청 경로를 가지고 경로와 메소드이름이 맞는지 체크해서 invoke 를 통해 동적으로 호출할 수 있다.
5. 스프링에서는 service 에 repository 같은 것을 의존할때 리플렉션을 사용해 repository 객체를 service 의 repository 필드에 주입할 수 있다. 

즉 컴파일 시점에는 알 수 없는 클래스, 메서드, 필드에 동적으로 접근할 수 있다.
직렬화,역직렬화 같은 여러 객체의 공통문제를 손쉽게 처리할 수 있다.
프레임워크에서 리플렉션을 활용하여 개발자에 편리한 기능을 제공할 수 있다.(의존성 주입, AOP, 어노테이션)

-----

# synchronized가 어떻게 한번에 하나의 thread 실행을 보장하는지
각 객체는 내부적으로 모니터라는 동기화 메커니즘을 가지고 있고 모니터는 객체에 대한 접근을 관리한다.
synchronized 를 사용하면 모니터에 접근하게 되는데 모니터에 접근하려면 일단 락을 획득해야한다.
다른 스레드가 락을 가지고 있다면 해당 스레드는 먼저 모니터에 접근한 스레드의 락이 해제될 때까지 대기하게된다.
예를들어 A 클래스의 a 메서드가 싱크로나이즈드로 만들어졌다면, 여러 스레드들은 먼저 A 객체의 락을 획득해야하고, 동시에 한 스레드만 a를 실행할 수있다.

----

# java에서 synchronized 키워드 말고 동시성을 관리하는 방법에는 또 뭐가 있을까?
## ReentrantLock Lock 과 Condition
JDK 1.5 에서 추가된 기능이다. 재진입 가능한 락을 구현, 같은 스레드가 이미 획득한 락을 다시 획득할 수 있다.
lock() 으로 락을 획득하고 unlock()으로 락을 해제한다.
명시적으로 락을 제어할 수 있고 락을 생성할때 공정성을 설정할 수 있다. (생성자의 매개변수를 true 로 주면 가장 오래 기다린 스레드가 락을 가져간다. -> 누가 오래기다렸는지 체크해야하므로 성능은 떨어진다.)

## ReentrantReadWriteLock
읽기에는 공유적이고, 쓰기에는 배타적인 락.
읽기를 위한 lock 과 쓰기를 위한 lock 을 제공한다.
읽기 락이 걸려있으면 다른 스레드가 읽기 락을 중복해서 걸고 읽기를 수행할 수 있다. 읽기는 내용을 변겨하지 않으므로 동시에 여러 스레드가 접근해도 문제 되지 않기 때문이다.
반면 읽기 락이 걸린 상태에서는 쓰기 락을 거는 것은 허용되지 않는다.

## stampedLock
ReentrantReadWriteLock 에 낙관적인 lock의 기능을 추가한 락.
락을 걸거나 해지할 때 스탬프(long 타입의 정수값)을 사용하여 읽기 쓰기 락 외에 낙관적 읽기를 추가했다.
읽기 락이 걸려있으면 쓰기 락을 얻기 까지 읽기 락이 풀리기를 기다려야하는데, 낙관적 읽기 락은 쓰기 락에 의해 바로 풀린다.
무조건 읽기 락을 걸지 않고 쓰기와 읽기가 충돌할 떄만 쓰기가 끝난 후에 읽기락을 새로 거는 것이다.

## tryLock()
다른 스레드에 의해 lock 이 걸려있으면 lock을 얻으려고 기다리지 않거나 지정된 시간 만큼만 기다린다.
lock()은 락을 얻을때까지 스레드를 블락시키므로 응답성이 나빠질 수 있는데 tryLock()을 통해 지정된 시간 동안 lock()을 얻지 못하면 다시 작업을 시도할지, 포기할지 결정할 수 있게 하는 것이 좋다.

## Condition
wait(), notify() 는 스레드를 구분할 수 없는데 Lock 의 Condition 을 사용하면 condition 의 await(), signal()을 통해 wait(), notify()를 대신해 사용할 수 있다.
대기와 통지의 대상이 명확히 구분된다.

## Concurrent Collections
java.util.concurrent 패키지에 있는 ConcurrentHashMap, CopyOnWriteArrayList, BlockingQueue 와 같은 동시성을 관리하는 컬렉션들이있다.
내부적으로 

---

# thread와 IO 작업의 관계
프로세스마다 하나의 스레드는 기본으로 가지고 있다.
스레드는 프로그램의 코드를 한줄 한줄 실행하는 역할을 하고 이 역할을 하기위해서는 스레드가 CPU를 써야한다.
스레드는 IO 작업(다른 장치에 일을 맡기는 행위)를 하게 되면 대기 시간이 발생한다.
이 대기시간은 DB에 작업을 요청하고 기다리고, 네트워크로 전송하고 응답 기다리고, 파일 복사하는 등의 작업이며 CPU를 사용하지 않는다.
그 동안 이 스레드가 점유한 CPU는 대기를 기다리느라 놀고있는 상태이다. 뒤에 처리해야할 다른 요청이 많은데도 이 대기를 기다리느라 제대로 처리하지 못한다.
따라서 이럴때는 멀테스레드를 이용해 대기가 발생하는 스레드를 대기 큐에 넣어 놓고 다른 스레드부터 CPU를 사용하게 해주는게 더 효율적이다.

스레드의 숫자는 CPU-바운드가 많은가, IO-바운드가 많은가에 따라 달라질 수 있다.
CPU를 더 많이 쓰는 작업이라면, CPU 코어수만큼 또는 그보다 하나정도 많은것이 좋다.
IO바운드일때느네 스레드가 중간중간 많이 쉬게 된다. CPU코어보다 훨씬 많은 수를 잡아야한다.
이 스레드들이 모두 CPU를 사용하는게 아니므로 CPU가 놀게 하지 않기 위해 스레드가 많아야 한다.

--- 
# IO 에서 병목이 발생하는 원인

--- 

# System.out.println()와 logger의 성능 차이

---

# nonblocking api 디버깅 하는 것의 어려움

---

# 새롭게 connection을 맺는게 오래 걸리는 이유
커넥션을 생성할때마다 인증, 세션초기화, 핸드셰이크 등의 과정이 발생하고 이 과정들은 오래 걸린다.
1. 디비에 연결하기 위해서는 사용자 ID 와 비번을 검증해야하는데 이 검증과정에 대한 시간 소요
2. 커넥션이 설정되면 디비는 해당 세션에 대한 초기변수를 설정해야하는데 이 초기화 시간이 소요
3. TCP 연결을 설정할때 패킷을 주고받으며 연결을 설정하는데 이 과정이 추가로 발생

-----
# close를 호출하지 않으면 어떤 이슈가 발생할 수 있는지?
디비 서버에 연결할 수 있는 최대 connection 수가 있는데 이를 낭비하게 되면 커넥션이 고갈될 수 있다.
커넥션이 많아지면 디비 서버가 더 많은 커넥션을 관리해야하므로 CPU, 메모리 자원을 낭비해 응답 시간이 느려질 수 있다.
커넥션을 유지하기 위해 데이터베이스는 네트워크 소켓을 관리해야 합니다. 각 소켓은 커넥션이 존재하는 동안 네트워크 자원을 사용하며, 이로 인해 시스템 오버헤드가 발생

## 커넥션풀은 왜 close 를 안하고 재사용함?
일반적으로 데이터베이스 커넥션에서 close() 메서드는 커넥션을 종료하고 해당 자원을 해제하는 역할을 합니다.
그러나 커넥션 풀에서는 close() 메서드를 호출할 때 실제로 커넥션을 종료하지 않고, 해당 커넥션을 풀로 반환하는 방식으로 작동합니다.
즉, 커넥션 풀은 커넥션을 "종료"하는 대신 "해제"하는 것입니다.
풀은 커넥션을 사용할 때와 반환할 때 적절한 초기화 및 검증 작업을 수행하여 불필요한 리소스 소모를 방지합니다.
## 커넥션 종료와 해제의 차이
- 커넥션을 종료하는 것은 해당 커넥션을 완전히 닫고, 데이터베이스와의 연결을 끊는 것을 의미
- 커넥션 풀에서 커넥션을 해제하는 것은 해당 커넥션을 종료하지 않고, 풀에 반환하는 것을 의미. 커넥션을 해제하면 커넥션은 여전히 데이터베이스와 연결된 상태를 유지하지만, 애플리케이션에서는 해당 커넥션을 더 이상 사용하지 않게 됩니다. 대기 상태로 전환

----

# RestTemplate를 왜 빈으로 등록하는게 좋을지?
빈으로 등록하게 되면 스프링이 싱글톤 패턴을 통해 하나의 인스턴스만 만들어 주므로 자원 낭비를 줄이고 여러 요청에 대해 동일한 객체를 재사용할 수 있다.
이미 생성된 객체를 재사용
빈으로 등록하면 HTTP 요청에 대한 공통 설정을 한 곳에서 관리할 수 있다.
의존성 주입을 통해 쉽게 주입받을 수 있어서 구현체를 교체하거나 mock 객체를 만들기 편리하다 -> 의존성을 명확하게 관리할 수 있다.

---

# 외부 서버에 요청하는 내용에 대해서 테스트를 하는 방법
