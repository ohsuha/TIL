## 기본형과 참조형
- Java에서 기본형과 참조형의 차이점은 무엇인가요?
  - 기본형은 byte, short, int, long, float, double, boolean 8개의 자료형을 말하며 참조형은 이 외의 모든 자료형입니다.
  - 기본형은 값의 불변성을 보장하며, 참조형은 데이터의 공유와 변경이 가능 불변성이 중요한 경우에는 기본형을, 데이터의 공유와 변경이 필요한 경우에는 참조형을 사용하는 것이 좋습니다.
- 기본형과 참조형의 메모리 할당 방식의 차이는 무엇인가요?
  - 기본형은 스택에 저장하며 실제 값을 가지고 있고 참조형은 힙에 저장되며 스택에는 힙의 메모리 주소를 저장합니다.
- 기본형과 참조형을 메서드 매개변수로 전달했을 때의 차이는 무엇인가요? 
  - 기본형을 매개변수로 전달했을 때는 pass by value 로 메소드 실행시 값을 복사해 메소드를 거쳐도 값이 변경되지 않지만,
  - 참조형은 pass by reference 로 주소값을 전달 후 실제 heap 에 있는 값이 변경 되기 때문에 메소드를 거치면 값이 변경될 수 있습니다.  
- 기본형과 참조형의 산술 연산에서의 차이는 무엇인가요? 
  - 기본형은 산술 연산이 가능하지만 참조형은 불가능합니다. 단, String 은 예외적으로 + 연산이 가능하빈다. 
- 기본형과 참조형의 null 할당 가능 여부는 어떻게 다른가요? 
  - 기본형은 null 을 할당할 수 없고 기본값이 지정되어있습니다. (0, 0.00000, false)
  - 참조형은 null 할당이 가능합니다.
- 기본형과 참조형의 성능 차이는 어떻게 되나요?
  - 기본형은 값 자체를 스택 메모리에 저장하므로 접근이 빠릅니다.
  - 반면에 참조형은 객체의 참조를 스택 메모리에 저장하고 실제 값은 힙 메모리에 저장되므로, 값을 사용할 때마다 언박싱(Unboxing) 과정을 거쳐야 합니다.
  - 이로 인해 기본형은 접근 속도가 더 빠르고, 참조형보다 빠른 연산이 가능합니다.

## 접근 제어자
- Java에서 접근 제어자의 종류와 그 차이점은 무엇인가요? 
  - public : 어디서든 사용이 가능합니다.
  - default : 같은 패키지 내에서만 사용이 가능합니다.
  - protected : 같은 패키지 내, 또는 상속받은 클래스에서만 사용이 가능합니다.
  - private : 같은 클래스 내에서만 사용이 가능합니다.
- 각 접근 제어자가 적용될 수 있는 범위는 어떻게 되나요?
  - method, class, 변수
- 접근 제어자를 사용하여 캡슐화를 구현하는 방법은 무엇인가요?
  - private 접근 제어자를 사용하는 방법이 있습니다.
- 디폴트 접근 제어자의 특징은 무엇인가요? 
  - 같은 패키지 내에서만 사용이 가능합니다.
- 퍼블릭 클래스의 제약 사항은 무엇인가요? 
  - 파일과 이름이 같아야하며 단 하나만 존재해야합니다.
- 접근 제어자를 사용하여 상속 관계에서의 접근을 제어하는 방법은 무엇인가요?
  - 클래스에 protected 를 통해 상속관계에서만 접근을 허용하게 할 수 있습니다.
  
## 메모리 구조
- Java의 메모리 구조는 어떻게 되어 있나요?
  - JVM이 가지는 메모리 영역 안에 Runtime Data 영역이 있습니다.
  - runtime data 영역은 크게 메소드, 스택, 힙 영역 세가지로 나뉩니다.
  - 메소드 영역은 클래스나 변수의 정보, 스태틱으로 지정한것들이 저장됩니다. 프로그램의 모든 영역에서 공유됩니다.
- JVM의 힙 메모리와 스택 메모리의 차이점은 무엇인가요?
  - 힙 영역은 new 를 통해서 참조 자료형을 생성했을때 참조 자료형이 저장되는 공간입니다. 모든 스레드가 공유합니다. 더이상 참조되지 않는 객체는 가비지 컬렉터가 삭제합니다.
  - 힙은 동적 메모리 할당으로, 프로그램 실행 중에 메모리 크기가 결정되며, 개발자가 직접 메모리를 할당하고 해제해야 합니다. 이는 스택보다 유연하지만, 메모리 관리에 더 많은 주의가 필요합니다.
  - 스택 영역은 메소드를 실행할때 메소드의 실행에 필요한 메모리를 제공하는 영역입니다. 스레드마다 하나씩 생깁니다. 기본 자료형, 참조 자료형의 heap 주소를 저장합니다. 후입선출 로 되어 속도가 빠릅니다. 메소드가 완료되면 사라집니다.
  - 스택은 정적 메모리 할당으로, 컴파일 시간에 메모리 크기가 결정되며, 함수 호출 시 자동으로 메모리가 할당되고 해제됩니다.
- 스택 메모리에서 메서드 호출 시 변수들이 어떻게 관리되나요?
  - 차곡차곡 쌓이는 형태로 저장되는데 따라서 가장 나중에 들어온 것이 우선적으로 사용됩니다.
- 힙 메모리에서 객체가 생성되고 관리되는 방식은 무엇인가요?
  - 가비지 컬렉터에 의해 관리됩니다.
  1. Eden 영역에서 객체가 생성
  2. Eden 영역이 꽉 차면 살아있는 객체만 Survivor 영역으로 복사되고, 다시 Eden 영역을 채우게 됩니다.
  3. Survivor 영역이 꽉 차게 되면 다른 Survivor 영역으로 객체가 복사된다. 이때, Eden 영역에 있는 객체들 중 살아있는 객체들도 다른 Survivor 영역으로 간다. 즉 Survivor 영역의 둘중 하나는 반드시 비어 있어야 한다. 이 부분을 `minor GC`, `young GC` 라고 부릅니다.
  4. 오래 살아있는 객체들은 Old 영역으로 이동한다. 지속적으로 이동하다가 Old 영역이 꽉 차면 garbage collection 이 발생하는데 이것을 `major GC`, `Full GC` 라고 부른다.
- 쓰레드별로 공유하는 메모리 영역과 공유하지 않는 메모리 영역의 차이는 무엇인가요?
  - 공유하는 메모리 영역은 메소드, 힙영역이 있으며 동시성 이슈가 발생할 수 있습니다. 이를 방지하기 위해 synchronized, lock 등을 겁니다.
- Garbage Collection이 메모리 관리에 미치는 영향은 무엇인가요?
  - 더이상 참조하지 않는 객체를 삭제 함으로써 heap 영역의 메모리를 정리합니다.
  - 단 inner 클래스와 같이 사용하지 않는데 계속해서 참조를 하게되는 경우 메모리 누수가 발생할 수 있습니다.

## 클래스와 객체
- Java에서 클래스와 객체의 차이점은 무엇인가요?
  - 클래스는 객체를 만들기 위한 큰 틀로 설계도 같은 역할을 합니다.
- 클래스와 객체의 관계를 설명해보세요. 
  - 붕어빵틀과 붕어빵
- 클래스를 사용하여 객체를 생성하는 방법은 무엇인가요?
  - Class1 class = new Class1(); 이런 식으로 생성자를 new 로 호출하여 사용합니다. 
- 객체 지향 프로그래밍에서 클래스의 역할은 무엇인가요?
  - 가장 기본이 되는 단위이고 객체를 생성하기위한 틀입니다.
- 클래스와 객체를 사용하여 캡슐화를 구현하는 방법은 무엇인가요?
  - private 을 사용하여 클래스의 내부를 감춘다.
- 클래스와 객체를 사용하여 다형성을 구현하는 방법은 무엇인가요?
  - 자식 클래스에 extends 부모 클래스 와 같이 선언해 부모의 변수, 메소드를 상속받아서 사용합니다.
  - 상속을 통해 부모의 참조 자료형으로 자식을 객체화 합니다.
  - 이렇게 되면 부모의 참조 자료형으로 자식의 오버라이딩한 메소드를 사용할 수 있습니다.
  - 또는 매개변수로 부모의 자료형을 받을때 부모 형태의 자식 객체를 넣을 수 있습니다.

## 스택과 큐 자료구조
- Java에서 스택과 큐 자료 구조의 차이점은 무엇인가요?
  - 스택은 후입선출, 큐는 선입선출을 목적으로 만들어졌습니다.
- 스택과 큐의 사용 사례를 설명해보세요. 
  - 스택은 자바에서 메소드 실행시 메소드 내부의 어떤 다른 메소드 호출.. 이런식으로 있을때 나중에 요청한 것 부터 실행시켜야하는 상황에서 사용
  - 큐는 먼저 요청한 것이 먼저 실행되야 하므로 순번 대기표나 요청을 순차적으로 처리해야할때 사용 됩니다. rmq 
  - 스택과 큐의 시간 복잡도는 어떻게 되나요? 
    - 삭제나 삽입시 맨 위에 데이터를 삽입하거나 삭제하기 때문에 시간복잡도는 늘 O(1) 의 시간복잡도를 가집니다. 하지만 특정 데이터를 찾을 때는 특정 데이터를 찾을 때까지 수행을 해야하므로 O(n) 의 시간 복잡도를 가집니다.
    - Java에서 스택과 큐를 구현하는 방법은 무엇인가요?
      - queue : 
        - ```commandline
            import java.util.LinkedList;
            import java.util.Queue;
          
            public class QueueExample {
            public static void main(String[] args) {
            // 큐 생성
            Queue<Integer> queue = new LinkedList<>();

            // 요소 추가 (offer)
            queue.offer(1);
            queue.offer(2);
            queue.offer(3);

            // 큐의 맨 앞 요소를 출력하고 제거 (poll)
            System.out.println("Polled element: " + queue.poll()); // 1

            // 큐의 맨 앞 요소를 확인 (peek)
            System.out.println("Front element: " + queue.peek()); // 2

            // 큐가 비었는지 확인
            System.out.println("Is queue empty? " + queue.isEmpty()); // false
 
            // 큐의 모든 요소를 출력
            System.out.println("Queue elements: " + queue);
           }
          }
          ```
      - stack :
        - ``` 
          import java.util.Stack;
  
          public class StackExample {
          public static void main(String[] args) {
             // 스택 생성
             Stack<Integer> stack = new Stack<>();

              // 요소 추가 (push)
              stack.push(1);
              stack.push(2);
              stack.push(3);

               // 스택의 맨 위 요소를 출력하고 제거 (pop)
               System.out.println("Popped element: " + stack.pop()); // 3

               // 스택의 맨 위 요소를 확인 (peek)
               System.out.println("Top element: " + stack.peek()); // 2

               // 스택이 비었는지 확인
               System.out.println("Is stack empty? " + stack.isEmpty()); // false

               // 스택의 모든 요소를 출력
               System.out.println("Stack elements: " + stack);
             }
          }

          ```
- 스택과 큐의 메모리 관리 방식은 어떻게 다른가요?
  - 배열로 구현했는가 linked list 로 구현했는가에 따라서 다릅니다.(?)