## 자바 문자열 풀(Java String Pool)
  - 힙 메모리의 특수한 영역으로 동일한 문자열을 재사용하기 위해 관리하는 메모리 공간
  - 메모리 효율을 향상시키기 위한 목적으로 사용된다.
  -  동일한 문자열 리터럴을 재사용하는 메커니즘입니다. 리터럴로 생성된 문자열은 풀에 저장되어, 동일한 문자열이 여러 번 사용될 때마다 새 객체를 생성하는 대신 풀에서 기존 객체를 재사용합니다. 이는 메모리를 절약하고 성능을 향상시키는 중요한 역할을 합니다.
  - ```commandline
    String str1 = "Hello";
    String str2 = "Hello";
    ```
    - 이 경우 Java는 문자열 풀에서 "Hello"라는 문자열이 이미 존재하는지 확인하고, 존재한다면 그 주소를 str1과 str2에 할당
    - str1 == str2 가된다.
    - 리터럴 문자열은 풀에 저장: Java는 리터럴로 선언된 문자열을 문자열 풀에 저장합니다. 동일한 리터럴이 여러 번 사용될 경우, 새로운 메모리를 할당하지 않고 이미 풀에 존재하는 문자열의 참조를 반환합니다.
  - ```commandline
    String str3 = new String("Hello");
    ```
    - 이 경우 새로운 String 객체를 힙 메모리에 생성한다.
    - new 를 통해 생성하므로 str1 == str3 은 false 가 된다.
    - 하지만 str3.equals(str1) 은 true 인데 이것은 String 에서 오버라이딩한 equals 가 문자열의 값을 비교하기 때문
    - 문자열 풀에 있으면 문자열 비교 시 참조 비교(==)를 사용할 수 있어 성능이 향상될 수 있습니다. 이는 값 비교(equals())에 비해 훨씬 빠릅니다.
## 불변 객체(Immutable Object)
  - 불변 객체는 생성된 후에 그 상태를 변경할 수 없는 객체로, 코드의 안정성과 예측 가능성을 높이는 데 매우 유용합니다. 특히, 멀티스레드 환경에서 안전하며, 재사용 및 캐싱이 용이합니다. 그러나 상태 변경 시 새로운 객체를 생성해야 하기 때문에 성능에 영향을 미칠 수 있으며, 메모리 사용량이 증가할 수 있다는 단점도 있습니다.
  - final 로 선언된 클래스와 멤버변수들, 초기화는 생성자를 통해서만 할 수 있고 setter 가 없다.
## ==과 equals의 차이 : 동일성과 동등성의 차이
  - == 연산자는 객체의 동일성을 판별하기 위해 사용하며, equals연산자는 두 객체의 동등성을 판별하기 위해 사용
  - == : 동일성은 두 객체가 같은 메모리 주소를 가리키고 있는지를 의미합니다. 기본 자료형(primitive type)에서는 값 자체를 비교하지만, 참조 자료형(reference type)에서는 객체의 참조 주소를 비교
  - equals : 동등성은 두 객체가 같은 값을 가지고 있는지 메소드는 객체의 내부 상태(예: 필드 값)가 동일한지를 비교

## 객체 지향 프로그래밍과 절차 지향 프로그래밍의 차이점은 무엇인가요?
  - 객체 지향 프로그래밍은 객체(object)라는 단위를 중심으로 소프트웨어를 구성, 현실 세계를 모델링하여 문제를 해결하는 방식입니다. 객체들 간의 상호작용을 통해 프로그램이 동작
  - 객체 지향 프로그래밍(OOP)은 객체와 클래스를 중심으로 프로그램을 구성하여, 코드 재사용성과 유지보수성을 강조합니다.
  - 절차 지향 프로그래밍은 절차 또는 **루틴(함수, 메소드)**을 중심으로 프로그램을 구성, 문제를 단계별로 나누어, 순차적으로 작업을 수행
  - 절차 지향 프로그래밍은 함수와 절차를 중심으로 작업을 순차적으로 수행하는 방식으로, 비교적 간단하고 직관적인 코드 작성을 가능하게 합니다.
## 객체 지향 프로그래밍의 네 가지 주요 원칙은 무엇인가요?
  - 캡슐화 : 데이터를 외부로부터 보호하고, 객체의 내부 상태를 숨기는 원칙 객체 내부의 데이터(필드)를 직접 접근하지 못하게 하고, 대신 메소드를 통해서만 접근할 수 있도록 함. 외부에서 잘못 건드리는 것 방지
  - 상속 : 기존 클래스(부모 클래스 또는 슈퍼 클래스)의 속성과 메소드를 새로운 클래스(자식 클래스 또는 서브 클래스)가 물려받아 사용할 수 있게 하는 원칙입니다. 이를 통해 코드 재사용성을 높이고, 기존 클래스를 확장하여 새로운 기능을 추가할 수 있다.
  - 다형성 : 다형성은 같은 이름의 메소드가 다양한 방식으로 동작할 수 있게 하는 원칙 동일한 인터페이스를 사용하면서도 객체에 따라 다른 동작을 수행할 수 있습니다.
  - 추상화 :  객체의 복잡한 구현 세부 사항을 숨기고, 중요한 부분만을 노출하는 원칙
## 절차 지향 프로그래밍에서 사용되는 대표적인 언어들은 어떤 것들이 있나요?
  -  C, 파스칼
## 객체 지향 프로그래밍의 단점은 무엇일까요?
  - 작은 프로젝트에서 하려고 할때 오버헤드가 발생할 수 있다.
  - 러닝커브가 높다.
## 절차 지향 프로그래밍의 장점은 무엇인가요?
  - 간단하고 명료한 코드 작성 가능
  - 작은 프로젝트에서 효율적

# 메소드(Method) 영역과 힙(Heap) 영역의 차이점은 무엇인가요?
  - 메소드 영역에는 자바에서 사용되는 클래스들의 정보 및 static 으로 설정한 데이터가 들어있고 힙영역에는 생성한 객체들이 있습니다.
  - 힙영역은 GC 가 돌며 더이상 참조하지 않는 데이터를 삭제합니다.
# 자바 가비지 컬렉션(Garbage Collection)에 대해 설명해 주세요.
  - 힙 영역에서 더이상 사용하지 않는 데이터(참조되지 않는)를 삭제합니다.
# 힙 메모리와 스택 메모리의 차이점은 무엇인가요?
  - 힙 메모리는 크기가 가변적이고 스택은 크기가 고정되어있다.
  - 스택은 선입 후출
# 런타임 데이터 영역은 어떤 데이터들을 포함하나요?
  - 메소드영역, 힙, 스택, PC레지스터, 네이티브 메소드 스택
    - 네이티브 메소드는 자바 외의 언어로 작성된 메소드를 실행할 때(각 스레드별 독립적)
    - 각 스레드마다 존재하며 현재 실행중인 JVM의 주소를 가르킨다. 주소를 통해 실행 순서를 관리하는데 사용된다.
# JNI(Java Native Interface)가 메모리 구조에 미치는 영향에 대해 설명해 주세요.
  - Java Native Interface(JNI)는 자바 애플리케이션이 다른 프로그래밍 언어(C, C++ 등)로 작성된 네이티브 코드와 상호 작용할 수 있도록 하는 표준 인터페이스
  - 이를 통해 자바는 플랫폼 종속적인 기능이나 고성능 처리가 필요한 부분을 네이티브 코드로 구현하여 사용할 수 있습니다.
  - 메모리 구조에 미치는 영향에 대해서 잘 모르겠다.......

## 오버라이딩 시 접근 제어자의 변경 제한 사항은 무엇인가요?
  - 오버라이딩시 부모의 접근 제어자보다 좁은 범위로 설정이 불가능합니다.
## 오버로딩의 주요 이점은 무엇인가요?
  - 여러 이름을 사용하지 않고 하나의 이름으로 다양한 타입의 매개변수를 담아 사용할 수 있습니다.
## 오버로딩을 활용한 실제 사례를 설명해 주세요.
  - StringBuffer 의 append() 메소드, 여러 타입을 받을 수 있는 메소드들로 오버로딩 되어있다.
## 오버라이딩을 할 때 주의해야 할 점은 무엇인가요?
  - 예외를 부모의 메소드보다 더 많이 작성할 수 없다. 접근제어자의 범위를 부모보다 좁게 할 수 없다. 

## 다형성(Polymorphism)에 대해 설명해 주세요.
  - 부모타입의 참조 변수로 자식의 객체를 호출 할 수 있는 것
## 업케스팅과 다운케스팅의 차이점은 무엇인가요?
  - 업 캐스팅 : 자식클래스의 객체를 부모클래스 타입으로 변환, 명시적 형변환이 필요 없음
  - 다운 캐스팅 : 부모클래스 타입의 객체를 자식클래스 타입으로 변환하는 것, 명시적 형변환이 필요함
  - 명시적 형 변환이 필요한 이유 : 업캐스팅의 경우, 서브클래스 객체를 슈퍼클래스 타입으로 변환하는 것이므로, 이는 항상 안전한 변환입니다. 모든 Dog 객체는 Animal로 간주될 수 있으므로, 명시적 캐스팅이 필요하지 않습니다.
  - 그러나 다운캐스팅의 경우, 컴파일러는 슈퍼클래스 타입의 객체가 실제로 서브클래스의 인스턴스인지 확신할 수 없습니다. 런타임에 ClassCastException 이 발생할 수 있다.
## 자바에서 instanceof 연산자의 역할은 무엇인가요?
  - 객체의 실제 타입을 확인할 수 있습니다.
  - 부모의 타입이여도 true 를 반환합니다. dog instanceOf(Animal)
  - JDK 6 이전에는 instanceof와 명시적 캐스팅을 연달아 사용하면, 컴파일된 바이트코드에서 두 번의 타입 검사가 이루어질 수 있었습니다
  - 그러나 JDK 6에서는 컴파일러가 이러한 패턴을 인식하여, 이미 instanceof를 통해 obj가 String 타입임이 확인된 경우, 캐스팅 시의 중복된 타입 검사를 생략할 수 있습니다.
  - jdk6 에서는 연산자와 캐스팅을 연달아 사용할 때 발생할 수 있는 중복된 타입 검사를 제거해서 최적화 덕분에 컴파일된 바이트코드가 더 효율적으로 실행
  - 그렇다고 명시적 형변환 안해줘야하는 건 아님!
    - ```commandline
         if (obj instanceof String) {
         String str = (String) obj;
         // str 객체에 대해 작업 수행
         }
      ```
  - 하지만 JDK 16에서는 명시적 형변환도 필요없어진다! 패턴 매칭 for instanceof
  - instanceof 키워드와 동시에 타입을 확인하고, 해당 타입으로 변수를 선언할 수 있습니다.
  - 스코프 제한: 선언된 변수는 if 블록 안에서만 유효합니다. 즉, obj가 String 타입일 때만 str 변수를 사용할 수 있습니다.

## 다형성이 코드 유지보수에 미치는 긍정적 영향은 무엇인가요?
  - 동일한 인터페이스 또는 부모 클래스를 공유하는 객체들이 다양한 방식으로 동작할 수 있게 함으로써, 코드의 유연성을 높입니다.
  - 동일한 상위 클래스를 상속받은 여러 하위 클래스들이 존재할 때, 상위 클래스의 메서드를 이용해 여러 하위 클래스 객체를 처리할 수 있습니다. 코드의 중복을 줄일 수 있습니다.
  - 새로운 하위 클래스를 추가해야 할 경우, 기존 코드를 건드리지 않고도 프로그램의 기능을 확장할 수 있습니다
## 다형성이 성능상에 미치는 영향에 대해 설명해 주세요.(??????????)
  - JIT 컴파일러에 의한 인라인 최적화가 어려워질 수 있다. (런타임때 실제 메서드가 결정되므로)
  - 인라인 최적화가 이뤄지지 않으면 메서드 호출 스택이 깊어지고 성능이 저하될 수 있다.
  - 여러개의 상속 구조와 객체를 사용할 경우 CPU 캐시의 캐시미스를 유발 할 수 있따.
  - 하지만 대부분 최신 JVM 에서는 해결되는 문제, 다형성은 꼭 필요한 곳에 쓰자
## 추상 클래스와 인터페이스의 차이는 무엇인가요?
![img](https://mblogthumb-phinf.pstatic.net/MjAxOTA1MDJfMjgw/MDAxNTU2NzgxOTU1MTQz.RGnWHb27tbqx0435Xg6hZVwCwo6ovMjhfyvnMkh9lYYg.MdIGtbRGQL3TnGvHfLmcMjXEFjpws6PCvUhMc5a2m3cg.PNG.dyd4740/1.png?type=w800)
  - 추 : 메소드가 구현되어 있어도 상관없다.
  - 인 : 구현되어있는 메소드가 있으면 안된다.
## 추상 클래스와 인터페이스를 실제로 어떻게 결합하여 사용하는지 예를 들어 설명해 주세요.
  - extends 추상 impelments 인터1, 인터2
## 인터페이스의 디폴트 메소드(default method)에 대해 설명해 주세요.
  - 인터페이스를 구현한 클래스들에서 구현하지 않아도된다. 구현부가 있어도 괜찮다.
- 추상 클래스에서 구현된 메소드와 추상 메소드를 혼합하여 사용하는 사례를 설명해 주세요.
## 인터페이스에서 static 메소드의 용도와 사례를 설명해 주세요.
  - java 8 부터 사용 가능해졌다.
  - 인터페이스에서 static 메소드를 사용하면, 관련된 유틸리티 함수나 팩토리 메소드 등을 효율적으로 제공할 수 있습니다.
  - 이러한 메소드들은 인터페이스에 관련된 기능을 캡슐화하며, 인스턴스와 무관하게 호출할 수 있어 코드의 재사용성과 가독성을 높이는 데 기여합니다.
## 다중 상속의 문제점을 해결하기 위해 인터페이스가 왜 사용되는지 설명해 주세요.
  - 다이아몬드 문제 (Diamond Problem)
    - 다중 상속에서 가장 흔히 발생하는 문제 중 하나입니다. 다이아몬드 문제는 클래스가 두 개의 부모 클래스를 상속받고, 이 부모 클래스들이 동일한 상위 클래스를 상속받고 있을 때 발생합니다.
    - 이 상황에서, 최종 서브클래스는 상위 클래스의 메서드나 속성을 두 번 상속받게 되어, 어떤 경로로 상속된 메서드를 사용할지 모호해집니다.
  - 여러 부모 클래스로부터 상속받은 메서드와 속성들이 서로 충돌할 가능성이 있다
  - 어떤 클래스가 어떤 메서드를 상속받았는지 파악하기 어려워지고, 문제 발생 시 원인을 추적하기 어렵습니다.
  - 인터페이스는 구현되지 않은 메서드의 시그니처만 정의하며, 상태(필드)를 가지지 않습니다. 따라서 다중 상속과 달리 메서드 충돌의 문제가 발생하지 않습니다.
  - 인터페이스는 특정 기능(메서드)의 구현을 클래스에 강제할 수 있습니다. 이를 통해 공통된 기능을 정의하고, 구현 클래스가 이를 반드시 구현하도록 하여 일관성을 유지할 수 있습니다.
## 왜 인터페이스는 구현이고 추상클래스는 상속이라고 할까
  - 각 개념이 객체 지향 프로그래밍에서 수행하는 역할과 그에 따른 사용 방식이 다르기 때문입니다. 인터페이스는 구현을 강제하고, 추상 클래스는 상속을 통한 기능 확장을 지원합니다.
  - 인터페이스
    - 인터페이스는 특정 메서드들이 어떻게 구현되어야 하는지를 명시하지 않고, 어떤 메서드들이 반드시 존재해야 하는지만을 정의합니다.
    - 구현 클래스는 인터페이스를 "구현"합니다. 이는 클래스가 인터페이스에 정의된 모든 메서드를 반드시 구현해야 함을 의미합니다. 인터페이스를 구현하는 클래스는 인터페이스의 메서드 시그니처를 따르고, 해당 메서드의 실제 동작을 정의해야 합니다.
    - 인터페이스는 클래스를 특정 계약(contract)에 맞게 "구현"하도록 강제합니다. 이는 특정 기능이나 행동을 보장하면서도, 다양한 방식으로 구현될 수 있는 유연성을 제공합니다.
    - 인터페이스는 클래스가 반드시 구현해야 하는 동작의 계약을 정의합니다. 이는 다양한 클래스들이 동일한 기능을 서로 다른 방식으로 구현할 수 있게 하여, 다형성을 지원합니다.
  - 추상 클래스 : 
    - 추상 클래스는 클래스 계층 구조의 상위 클래스 역할을 합니다. 추상 클래스는 일부 메서드를 구현하고, 나머지 메서드들을 추상 메서드로 정의하여 하위 클래스가 이를 구현하도록 합니다.
    - 하위 클래스는 추상 클래스를 "상속"하며, 상속받은 메서드를 재정의(오버라이드)하거나 추가 메서드를 구현함으로써 구체적인 클래스를 완성합니다.
    - 추상 클래스는 특정 기능의 기본적인 구현을 제공하고, 이를 확장하여 하위 클래스에서 추가 기능을 구현하도록 설계되었습니다. 이는 코드 재사용을 촉진하고, 클래스 계층 구조를 통해 공통 기능을 중앙에서 관리할 수 있게 합니다.
    - 추상 클래스는 코드 재사용과 클래스 계층 구조를 지원하며, 기본적인 기능을 제공하는 상위 클래스로서 하위 클래스들이 이를 상속하고, 필요한 부분을 재정의할 수 있게 합니다.