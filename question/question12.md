# get은 o(1) 인데 skip list와 레디스의 관계 찾아보기
내부적으로 Sorted Set 자료 구조를 구현하기 위해 Skip List를 사용.
Redis에서 일반적인 GET 연산은 단순한 키-값 조회로, O(1) 시간 복잡도를 가진다.

Sorted Set(ZSET) 구현에 사용: Redis의 Sorted Set(ZSET)은 데이터를 정렬된 상태로 저장하고 빠르게 순위나 범위 검색을 지원합니다.
이를 위해 Redis는 Skip List와 Hash Table을 함께 사용합니다.
- Skip List는 원소들을 자동으로 정렬하여 O(log N) 시간 복잡도로 조회, 삽입, 삭제가 가능합니다. 특정 범위의 원소를 찾을때 스킵 리스트를 활용하여 매우 빠르게 탐색한다.
- Hash Table은 키와 값을 빠르게 매핑하여 키 기반 조회 시 O(1) 성능을 보장합니다.

## skip list 는 어떻게 되어있는가?
Skip List는 정렬된 데이터를 빠르게 검색할 수 있도록 설계된 자료구조.
일반적인 연결 리스트를 여러 "층(level)"으로 쌓아 올려, 일부 원소를 건너뛰며 빠르게 탐색할 수 있도록 만들어졌다.
- 기본 연결 리스트: 가장 아래층(Level 0)은 일반적인 정렬된 연결 리스트입니다. 이 층만으로는 순차 검색만 가능하기 때문에 탐색에 O(N) 시간이 걸립니다.
- 위층의 지름길: Level 0 위에는 각 층마다 연결된 노드의 수가 점점 줄어드는 "지름길" 층이 존재합니다.
  - 예를 들어, Level 1은 Level 0의 절반 정도의 노드만 연결하고, Level 2는 Level 1의 절반만 연결하는 식입니다.
  - 이 위층의 노드들은 "키"가 작은 일부 노드들만 포함되어 있어, 탐색할 때 여러 개의 노드를 건너뛸 수 있는 "지름길" 역할을 합니다.

가령, 정렬된 숫자 1에서 10까지를 Skip List에 저장한다고 하면:

Level 2 (최상위 층): 1 ———— 5 ———— 9
Level 1: 1 —— 3 —— 5 —— 7 —— 9
Level 0 (전체 리스트): 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10
위처럼 여러 층을 만들어 두면, 예를 들어 8을 찾을 때 Level 2에서 시작해 5로 이동하고, 다음으로 Level 1에서 7로 이동하여 최종적으로 Level 0에서 8을 찾게 됩니다.
이 과정에서 일부 노드를 "건너뛰어" 탐색 속도를 높입니다.

## 스킵리스트와 해시테이블 get 이 어떻게 연결 되어있는지?


# redis의 메모리가 다 소모되었을 때, 에러 내는 방법 말고 다르게 처리하는 방법 찾아보기
## 메모리 정책 설정
메모리가 부족할때 사용할 수 있는 데이터 삭제 정책을 사용한다. 이러한 정책은 redis.conf 파일에서 maxmemory-policy 옵션을 통해 설정
- allkeys-lru: 모든 키 중에서 가장 최근에 사용되지 않은 데이터를 삭제합니다. LRU(Least Recently Used) 알고리즘을 사용하여 가장 오랫동안 사용되지 않은 데이터를 먼저 삭제하므로, 자주 사용하는 데이터를 남길 수 있습니다. 
- volatile-lru: 만료 시간이 설정된 키 중에서 가장 오래된 데이터를 삭제합니다. 주로 캐싱 목적으로 사용되는 데이터에서 자주 활용됩니다. 
- allkeys-random: 모든 키 중에서 무작위로 데이터를 삭제합니다. 자주 사용하는 데이터도 삭제될 수 있어 잘 사용되지 않지만, 특정 용도에서는 간단하게 메모리를 확보하는 데 도움이 됩니다. 
- volatile-random: 만료 시간이 설정된 키 중에서 무작위로 삭제합니다. 주로 캐시 목적의 데이터에서만 무작위로 삭제를 적용합니다. 
- volatile-ttl: 만료 시간이 설정된 키 중에서 TTL(Time-To-Live)이 가장 가까운 데이터를 삭제합니다. 곧 만료될 데이터를 먼저 삭제하여 시스템의 메모리를 확보합니다.

## TTL Time To Live 설정
데이터를 저장할 때 TTL을 설정하여 특정 시간이 지나면 자동으로 삭제되도록 하는 방법, Redis에 저장하는 경우, 만료 시간이 있는 데이터만 남기고 오래된 데이터를 제거할 수 있다.
```SET key value EX 60```

## 데이터 압축
일부 데이터는 압축을 통해 메모리를 절약할 수 있습니다. Redis의 MEMORY USAGE 명령을 사용하여 각 키의 메모리 사용량을 분석한 후, 필요에 따라 데이터를 효율적으로 관리합니다.


# 로컬 인메모링 캐싱 vs 레디스 캐싱
## 로컬 인메모리 캐싱
애플리케이션 서버의 메모리 내에서 데이터를 저장하고 활용하는 방식,
Ehcache, Caffeine, Guava Cache 등이 로컬 캐싱 라이브러리이다.
### 장점
- 빠른 접근 속도 : 네트워크를 거치지 않아 빠르게 접근 가능함
- 설정이 간단 : 외부 시스템이 필요 없고 애플리케이션 내부에서만 설정이 이뤄져 유지보수가 간단
- 저렴한 비용 : 외부 서버가 필요 없으므로 비용이 적게 든다.
### 단점
- 여러 서버 인스턴스가 있는 경우 각각의 인메모리 캐시가 독립적으로 동작하기 때문에 일관성을 유지하기 어렵다.
- 애플리케이션이 재시작되면 캐시 데이터가 모두 사라진다.
### 적합한 상황
- 단일 서버에서 운영되는 애플리케이션
- 데이터 일관성보다는 빠른 접근이 중요한 경우
## 레디스 캐싱
네트워크를 통해 접근 가능한 외부 메모리 데이터베이스로, 분산 캐시로 많이 사용된다.
### 장점
- 여러 서버 인스턴스가 Redis 를 통해 동일한 캐시 데이터를 공유하기 때문에 일관성을 유지할 수 있다.
- 캐시 서버를 확장하여 많은 데이터를 저장할 수 있고 여러 인스턴스가 같은 캐시를 사용할 수 있다.
- 레디스는 영속성을 지원하므로 서버 재시작 후에도 데이터가 유지될 수 있다.
### 단점
- 네트워크 오버헤드 : 네트워크를 통해 접근하므로 메모리 캐시보다는 다소 느리다
### 적합한 상황
- 다중 서버 환경에서 일관성과 데이터 공유가 중요한 경우
- 다중 인스턴스 환경에서 일관성 있는 캐시 데이터가 필요한 경우
- 세션 관리, 사용자 인증 등과 같이 여러 서버에서 동일한 캐시 데이터를 사용해야하는 경우
- 데이터 영속성이 필요하거나, 데이터 크기가 커서 로컬 캐시에 적합하지 않은 경우

# redis로 락을 구현할때 어떤 방법을 통해서 구현하는지 주로 2가지 방법이 있는데 각각 찾아보기

# 각각의 디자인 패턴들이 어떤 문제를 해결하고 싶었는지의 관점에서 좀 더 생각해보기
### 1. 싱글톤 패턴 (Singleton Pattern)
- **문제**: 애플리케이션에서 **특정 클래스의 인스턴스가 오직 하나만** 생성되도록 보장, 애플리케이션의 설정 정보나 데이터베이스 연결처럼 공통된 리소스를 관리할 때 중복 생성은 비효율적입니다.
- **해결 방법**: 싱글톤 패턴은 클래스의 인스턴스를 하나만 생성하고, 이를 전역적으로 공유할 수 있게 해줍니다.
- **적용 사례**: 설정 관리, 데이터베이스 연결, 로그 기록, 캐시 관리.

- 빈을 싱글톤으로 등록하는 이유는 의존 관계 주입할때마다 매번 새로운 객체를 생성한다.
- 의존 관계들을 매번 새로 엮어주는 것은 상당히 힘든 일이다.
- 수십개씩 연결될 수 있는 객체를 만들려면 연산만으로도 복잡할 수 있다.
- 싱글톤은 스태틱이랑은 관계가 없다. 싱글톤을 구현하는 한가지 방법으로 static 을 사용하는 방법이 있을 뿐이다.
- 변수 자체는 스택에 쌓이고 객체 자체는 힙에 쌓이는 것처럼 싱글톤도 힙에 쌓인다.

---

### 2. 전략 패턴 (Strategy Pattern)
- **문제**: 특정 기능(예: 정렬 방식, 할인 정책 등)이 여러 가지 방식으로 구현될 수 있을 때, 이러한 방식들을 독립적으로 관리하면서 **동적으로 선택**할 수 있도록 설계하고 싶을 때가 있습니다. 예를 들어, 사용자에 따라 서로 다른 결제 방식이나 배송 정책을 적용할 수 있어야 한다면 하나의 클래스에 모든 조건을 넣는 것은 비효율적입니다.
- **해결 방법**: 전략 패턴은 특정 기능을 여러 알고리즘(전략)으로 분리하고, 이를 필요에 따라 **런타임에 교체**할 수 있게 합니다. 즉, 전략 객체를 교체함으로써 동적으로 기능을 변경할 수 있습니다.
- **적용 사례**: 결제 시스템에서의 다양한 할인 정책, 게임에서의 AI 행동, 데이터 정렬 방식의 선택.
- 여러 전략들을 상황에 맞게 쓸 수 있게 하기 위한 패턴

### 3. 템플릿 메서드
- 정해진 틀이 있고 일부분에 구멍이 있고 각각의 구현체가 채워 넣는 느낌에 가깝다.
- 

---

### 3. 팩토리 메소드 패턴 (Factory Method Pattern)
- **문제**: 객체 생성 과정에서 어떤 클래스의 인스턴스를 생성할지 **구체적으로 명시하지 않고도 객체를 생성**할 수 있어야 할 때가 있습니다. 예를 들어, 다양한 유형의 데이터를 불러오는 클래스들이 있는데, 각 유형마다 생성 과정이 다르다면 이를 일반화하기 어려워집니다.
- **해결 방법**: 팩토리 메소드 패턴은 **상속을 통해 객체 생성을 위임**하여 객체 생성 코드를 캡슐화하고, 구체 클래스의 인스턴스를 생성할 때 클라이언트가 직접 클래스에 의존하지 않도록 합니다.
- **적용 사례**: GUI 애플리케이션에서 버튼을 생성할 때, 데이터베이스 연결 객체를 생성할 때.

---

### 4. 옵저버 패턴 (Observer Pattern)
- **문제**: 객체의 상태가 변할 때 다른 객체들에 **자동으로 알리고 반응할 수 있도록** 설계하고 싶을 때가 있습니다. 예를 들어, 뉴스 애플리케이션에서 특정 주제의 뉴스가 업데이트될 때 해당 주제에 구독한 사용자들에게 알림을 보내야 한다면 상태 변화를 추적하는 것이 중요합니다.
- **해결 방법**: 옵저버 패턴은 한 객체의 상태가 변하면 이를 **구독하고 있는 다른 객체들에 자동으로 통보**하는 방식으로 동작합니다.
- **적용 사례**: 이벤트 알림 시스템, GUI의 이벤트 리스너, 실시간 데이터 스트림 구독.

---

### 5. 데코레이터 패턴 (Decorator Pattern)
- **문제**: 객체의 기능을 변경하거나 확장할 때, 기존 클래스에 **불필요한 서브클래스를 추가하지 않고도** 동적으로 기능을 추가하고 싶을 때가 있습니다. 예를 들어, 다양한 형식의 데이터 스트림을 제공해야 하는데 모든 경우의 수를 서브클래스나 if 문으로 작성하기는 번거롭습니다.
- **해결 방법**: 데코레이터 패턴은 객체를 **다른 객체로 감싸서 추가 기능을 덧붙이는 방식**으로 동작합니다.
- **적용 사례**: 파일 입출력 스트림(예: BufferedReader로 InputStream을 감싸는 방식), 메시지의 암호화/압축 기능 추가.

---

### 6. 프록시 패턴 (Proxy Pattern)
- **문제**: 객체에 직접 접근하기 전에 **접근을 제어**하거나 **추가 작업**을 수행해야 하는 경우가 있습니다. 예를 들어, 원격 서버에 있는 리소스에 직접 접근할 때 부하가 크거나, 접근을 제한해야 한다면 이를 관리할 방법이 필요합니다.
- **해결 방법**: 프록시 패턴은 **대리 객체를 통해 실제 객체에 접근**할 수 있도록 하여, 필요한 경우에만 실제 객체를 생성하거나 접근할 수 있게 합니다.
- **적용 사례**: 가상 프록시(리소스를 효율적으로 사용하는 경우), 보안 프록시(접근 권한이 필요한 경우), 원격 프록시(원격 리소스에 접근하는 경우).


# bean scope를 사용해서 빈의 생명주기를 다르게 가져가는 이유는 뭘지 고민해보기
빈 각자 유지됐으면 하는 기간이 달라서
빈이 너무 자주 생성되면 메모리 사용량이 증가하고 성능 저하가 발생할 수 있습니다.
반대로 너무 적게 생성되면 객체 간에 데이터가 공유될 위험이 있습니다.
각 스코프는 빈의 생명주기를 최적화하여 메모리와 성능을 효율적으로 관리하는 데 도움을 줍니다.

다양한 애플리케이션 요구사항에 맞게 빈의 생명주기를 설정함으로써 개발자는 특정 요청이나 세션 단위로 상태를 유지하거나, 공유할 수 있습니다.
다양한 스코프를 제공함으로써, 스프링은 다양한 애플리케이션 구조를 유연하게 지원할 수 있습니다.

빈 스코프는 불필요한 상태 공유를 방지하고, 특정 사용자나 요청에 고유한 객체를 제공하여 데이터의 무결성을 유지할 수 있게 해줍니다. 이는 특히 웹 애플리케이션에서 중요한 역할을 합니다.

# Index가 왜 빠른지?
인덱스가 빠른 이유는 데이터 검색을 최적화하여 필요한 레코드를 더 적은 I/O 작업으로 찾아낼 수 있기 때문.
## 어떻게 빠르게 만든걸까?
### 인덱스의 데이터 구조는 B-Tree, Hash
- B-Tree : 노드들이 정렬된 상태로 유지되어서 로그 시간 안에 데이터를 검색할 수 있고 원하는 값을 빠르게 찾을 수 있도록 정렬된 구조로 탐색하는 과정에서 검색 속도가 빨라진다.
- Hash : 특정 값을 입력하면 해시 함수를 통해 바로 위치를 찾을 수 있어 특정 값이 정확하게 일치하는 경우 매우 빠른 검색이 가능하다.
### 인덱스와 I/O 최적화
- 인덱스를 통해 테이블의 전체 데이터를 읽을 필요 없이 필요한 데이터가 저장된 데이터 페이지에 빠르게 접근할 수 있습니다.
- 검색 범위를 좁히고 필요한 데이터 페이지만 읽도록 도와 검색 시간을 단축시킨다.
### 정렬과 범위 검색 최적화
- 인덱스가 적용된 열은 정렬된 상태로 저장되므로 범위 조건이나 순서가 있는 검색이 매우 효율적으로 수행된다.
## 주의점
- 인덱스가 많아지면 데이터 수정(삽입, 갱신, 삭제) 시 인덱스도 같이 업데이트되어야 하므로, 삽입이나 업데이트 작업이 많을 경우 오히려 성능이 저하될 수 있습니다.

# inverted index는 어떻게 동작하는건지?
일반적인 인덱스는 특정 데이터 항목의 위치를 기록하여 검색을 빠르게 하지만, 역 인덱스는 각 단어에 대해 해당 단어가 포함된 문서나 위치 정보를 기록하여,
단어가 포함된 모든 위치나 문서를 빠르게 찾을 수 있게 한다.
특정 단어가 포함된 웹 페이지를 빠르게 찾기 위한 웹페이지, 문서 검색(도서관, 법률 문서) 등에서 사용된다.

예제: 다음과 같은 세 개의 문서가 있다고 가정합시다.

문서1: "cat eats fish"
문서2: "dog eats bone"
문서3: "cat and dog are friends"
```text
cat -> [문서1, 문서3]
eats -> [문서1, 문서2]
fish -> [문서1]
dog -> [문서2, 문서3]
bone -> [문서2]
and -> [문서3]
are -> [문서3]
friends -> [문서3]
```

- 단어 분리 및 정규화: 문서의 내용을 단어별로 나누고, 대소문자 정규화, 불용어 제거(예: the, and 같은 자주 등장하지만 검색에 불필요한 단어 제외) 작업을 수행합니다.
- 단어와 문서 ID 매핑: 각 단어에 대해 해당 단어가 등장하는 문서 ID를 기록하여 Posting List를 생성합니다.
- 색인 저장: 인덱스 정보를 데이터베이스나 메모리에 저장하여, 검색 요청이 있을 때 빠르게 해당 문서의 ID 목록을 반환할 수 있도록 합니다.