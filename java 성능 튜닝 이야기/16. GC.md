# GC란
객체는 메모리를 점유하고 필요하지 않으면 메모리에서 해제되어야한다.
그렇지 않으면 메모리가 가득차게 되는 상황이 발생한다. 이렇게 불필요한 객체를 메모리에서 해제시키는 역할을 하는것이 가비지 컬렉터이다.

자바는 힙 영역에서 GC 가 동작한다. GC 는 다음의 작동원리를 통해 수행된다.
- 메모리 할당
- 사용중인 메모리 인식
- 사용하지 않는 메모리 인식

## 힙의 메모리 구조
young 영역 : eden, survivor1, survivor2
old 영역 : 메모리
perm : jdk 1.8부터 사라짐

1. 메모리에 객체가 생성되면 Eden 영역에 객체가 지정된다.
2. 서바이버 영역은 2개가 있는데 둘 중하나는 반드시 비워져있다.
3. Eden 이 꽉차면 survivor 1 영역으로 옮겨진다. 이때 eden 에서 더이상 사용되지 않는 것은 옮겨지지 않는다.
4. survivor1 이 가득차면 survivor2 로 eden 의 객체와 함께 이동한다. 이걸 반복하다가 오래 살아남게 된 객체는 old 로 간다.
5. 객체의 메모리가 서바이버의 영역보다 크면 바로 에덴에서 올드로 가기도 한다.

minor GC : young 영역에서 발생하는 GC
major GC : old 영역에서 발생하는 GC

GC가 발생하거나 객체가 다른 영역으로 이동할때 병목이 발생하면서 성능에 영향을 준다.
핫스팟 JVM 에서는 스레드 로컬 할당 버퍼를 사용해 각 스레드별 메모리 버퍼를 사용, 다른 스레드에 영향을 주지 않도록 되어있다.
-> GC가 발생하거나 객체가 다른 메모리 영역으로 이동할 때 성능 저하가 발생할 수 있습니다. HotSpot JVM은 TLAB을 통해 각 스레드가 독립적인 메모리 버퍼를 가지게 하여 이러한 문제를 해결하고, 성능 저하를 최소화합니다. TLAB 덕분에 메모리 할당 시 경쟁이 줄어들고, 스레드 간의 영향을 최소화할 수 있습니다.

# GC의 종류
## STW : stop the world 
가비지 컬렉션 작업이 진행되는 동안 모든 어플리케이션 스레드를 중단시키는 것을 말한다.
1. 힙메모리 관리 : 스레드가 힙메모리를 수정하는 것을 막기 위해 모든 스레드를 일시적으로 중단시킨다.
2. 루트 스캔 : GC 는 객체가 살아있는지 여부를 확인하기 위해 루트 스캔을 수행하는데, 애플리케이션의 모든 스레드 상태를 검사해야한다. 스레드가 실행중인 상태에서는 객체 참조가 변할 수 있어 스레드를 멈춘 후 안정적인 상태에서 검사해야한다.

## 시리얼 콜렉터
단일 스레드로 수행되는 콜렉터, 모든 어플리케이션 스레드를 멈추고 수행된다.
young 과 old 영역이 연속적으로 처리되며 하나의 CPU 를 사용한다. 처리 과정에서 stw 가 발생한다.

### young
1. 에덴에 있다.
2. 에덴이 꽉차면 비어있는 서바이버로, 다른 서바이버에서도 살아있는 객체는 비어있는 서바이버로 이동한다. 용량이 너무 크면 바로 올드로 간다.
3. 서바이버가 꽉차면 에덴이나 다른 서바이버는 올드로 이동한다.

### old
mark-sweep-compact 콜렉션 알고리즘을 통해 쓰이지 않느 ㄴ객체를 삭제하고 살아있는 객체를 한곳으로 모은다.

### 장점
- 구현이 간단하고 단일스레드라 오버헤드가 적다.
- 메모리가 작고 멀티스레드 성능이 필요없는 작은 애플리케이션에 효율적이다.
### 단점
- GC 동안 모든 스레드가 멈춘다. 대용량 메모리나 멀티스레드환경에서 응답이 늦어진다.
- 병렬처리가 불가능, 하나의 스레드만 사용하기 때문에 멀티 코어 시스템의 성능을 다 활용하지 못한다.

## 병렬 콜렉터
여러 스레드를 사용하여 GC 를 병렬적으로 수행한다.

### young
콜렉션을 병렬로 처리한다.

### old 
시리얼과 마찬가지로 mark sweep compact 알고리즘을 사용해 객체를 한곳으로 몰아 넣는다.

### 장점
- 멀티 코어 시스템에서 더 나은 성능을 발휘, 여러 스레드가 동시에 GC 를 수행하므로 처리량이 더 높다.
- GC 동안 애플리케이션 스레드가 멈춘다. 처리량을 우선시해서 대기시간이 길어질 수 있다.

## 병렬 콤팩팅 콜렉터
병렬 콜렉터와 동일하지만 old 영역에서 새로운 알고리즘을 사용한다.
- 표시 : 살아있는 객체를 식별하여 표시
- 종합 : 이전에 GC 를 수행하여 컴팩션된 영역에 살아있는 객체의 위치를 조사하는 단계
- 컴팩션 : 컴팩션을 수행하는 단계, 수행 이후에는 컴팩션 된 영역과 비어있는 영역으로 나뉜다.

## CMS
힙 메모리 영역의 크기가 클때 적합하다. young 영역에 대한 GC 는 병렬콜렉터와 동일하다.
애플리케이션의 중단 시간을 줄이는 것을 목표로 한다.
대부분의 GC 작업을 애플리케이션 스레드와 동시에 처리한다.
컴팩션을 수행하지 않으므로 올드 영역에는 빈공간이 발생한다.

### old 
1. 초기 표시 단계 : 매우 짧은 대기시간으로 살아있는 객체를 찾느다.
2. 컨커런트 표시 : 서버 수행과 동시에 살아있는 객체에 표시를 한다.
3. 재표시 : 컨커런트 표시 단계에서 표시하는 동안 변경된 객체를 다시 표시한다.
4. 컨커런트 스윕 : 표시되어있는 쓰레기를 정리한다.

### 장점
- stw 시간이 짧다. 애플리케이션 스레드와 병행해서 진행된다.
- 응답시간이 유리하다. 대기시간이 짧아야하는 애플리케이션에 적합하다.

### 단점
- CMS 는 힙을 압축하지 않아서 메모리 단편화가 발생할 수 있다.
- 올드 영역에 남아있는 크기가 30mb여도 10mb 짜리 객체가 연속으로 들어갈 공간이 없을때 Concurrent mode failure 라는 경고가 발생하며 압축 작업을 수행한다.
- 이 압축시간이 병렬 콜렉터보다 더 오래 소요되어 문제가 될 수 있다.
- Concurrent Mark 단계에서 여러 스레드가 메모리를 스캔하면서 CPU 사용량이 증가

## G1
stw 시간을 줄이기 위해 설계, 메모리를 리전으로 나눠 관리하며 필요할때 마다 특정 영역에서만 GC를 수행하여 stw 시간을 최소화한다.
G1은 바둑판 모양으로 리전을 만든다. 영과 올드가 물리적으로 나뉘어 있지 않고 각 바둑판은 모두 크기가 동일하다.
각 바둑판의 칸들이 eden, survivor, old 역할을 변경해가면서 수행한다.

### young
1. 몇개의 구역을 선정하여 영영역으로 지정한다.
2. 이 구역들에 객체가 생성되면서 데이터가 쌓인다.
3. 영이 꽉차면 GC를 수행한다.
4. GC를 하면서 살아남은 객체만 서바이버로 이동한다.
5. 몇번의 에이징(몇번의 마이너 GC 가 있어도 살아남으면) 올드로 승격된다.

### old
1. 초기 표시(STW) : 올드 영역 개체에서 서바이버 영역 객체를 참조하고 있는 객체들을 표시
2. 기본 구역 스캔 : 올드 영역 참조를 위해서 서바이버 영역을 훑는다.
3. 컨커런트 표시 단계 : 전체 힙 영역에 살아있는 객체를 찾는다.
4. 재표시(STW) : 힙에 살아있는 객체들의 표시작업을 완료한다. 이때 Snapshot at the beginning 알고리즘을 써서 빠르게 수행된다.
5. 청소(STW) : 살아있는 객체와 비어있는 구역을 식별, 필요없는 객체를 삭제한다. 비어있는 구역을 초기화한다.
6. 복사(STW) : 살아있는 객체를 비어있는 구역으로 모은다.

### 장점
- 메모리 단편화 해결을 위해 GC 후 힙이 압축된다.
- 사용자 지정으로 GC의 최대 중단시간을 설정할 수 있다.
- 힙의 상태를 분석해 가장 많은 가비지를 포함한 영역을 먼저 처리하므로 효율적이다.

### 단점
- CPU 사용량이 증가한다.
- 설정과 튜닝이 복잡하다.

## ZGC
매우 짧은 STW를 목표로하여 10ms 이하의 중단시간을 제공한다.
- ZGC는 메모리 압축을 지원하지만, 이를 위해 프로그램을 일시 중지하지 않습니다. 대신에 "색인"이라는 기술을 사용하여 객체를 이동하고 참조를 업데이트합니다.
- ZGC는 큰 힙(수백 GB 이상)을 지원하며, 힙 크기가 커져도 가비지 수집 성능이 저하되지 않도록 설계되었습니다.
- ZGC는 객체의 크기에 따라 서로 다른 메모리 영역을 사용하여, 메모리 단편화를 줄이고 효율적인 메모리 사용을 가능하게 합니다.
- ZGC는 애플리케이션의 일시 중지 시간을 최소화하는 데 중점을 두고 설계되었습니다. 가비지 수집 중에도 응용 프로그램의 응답성을 유지할 수 있도록 합니다.
- ZGC는 가비지 수집 작업을 애플리케이션 스레드와 동시에 수행하여, 전체적인 성능 향상을 이룹니다.
### 단점
- ZGC는 저지연을 유지하기 위해 더 많은 메모리를 사용할 수 있으며, 이로 인해 메모리 자원의 낭비가 발생할 수 있습니다.
- ZGC는 모든 Java 버전 및 플랫폼에서 지원되지 않을 수 있습니다. 특정 버전과 운영 체제에서만 사용할 수 있습니다.
- 복잡한 작동 방식을 가지고 있어, 디버깅이 다른 가비지 수집기보다 어려울 수 있습니다.

# GC 상황 확인 jstat
## jps
jps 명령어는 Java Virtual Machine (JVM)에서 실행 중인 Java 프로세스 목록을 보여주는 유틸리티
```text
jps [-q] [-mlvV] [-Joption] [<hostid>]
```

| 옵션               | 설명                                           |
|-------------------|----------------------------------------------|
| `-l`              | 전체 클래스 이름 또는 JAR 파일의 경로를 출력합니다. |
| `-v`              | Java 프로세스에 전달된 VM 옵션을 출력합니다.  |
| `-m`              | Java 프로세스의 메인 메서드와 인자를 출력합니다.  |
| `-q`              | 프로세스 ID만 출력합니다.                   |
| `-J<옵션>`       | JVM에 직접 전달할 옵션을 지정합니다.        |
| `--help`          | 도움말 정보를 출력합니다.                    |

## jstat option
GC가 수행되는 정보를 확인하기 위한 명령어이다.

```text
jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]
```
| 요소           | 설명                                                       |
|----------------|----------------------------------------------------------|
| `-<option>`    | 모니터링할 통계 정보를 지정하는 옵션입니다. 예: `-gc`, `-class` 등. |
| `-t`           | 시간 스탬프를 출력합니다.                                |
| `-h<lines>`    | 출력되는 통계의 줄 수를 지정합니다.                      |
| `<vmid>`       | 모니터링할 JVM 프로세스의 ID입니다.                      |
| `<interval>`    | 통계를 수집할 간격(밀리초)을 지정합니다.                |
| `<count>`      | 통계를 수집할 횟수를 지정합니다.                        |

option 에는 여러가지가 있는데 GC 튜닝할때 가장 유용한 옵션은 -gcutil 과 -gccapacity 이다.

### -gcutil
| 열 이름 | 예시 응답 | 설명                                      |
|---------|-----------|-----------------------------------------|
| `S0`    | 0.00      | Survivor Space 0의 메모리 사용 비율(%)  |
| `S1`    | 0.00      | Survivor Space 1의 메모리 사용 비율(%)  |
| `E`     | 15.00     | Eden Space의 메모리 사용 비율(%)       |
| `OC`    | 20.00     | Old Generation의 메모리 사용 비율(%)    |
| `MC`    | 60.00     | Metaspace의 메모리 사용 비율(%)        |
| `CCS`   | 50.00     | Compressed Class Space의 메모리 사용 비율(%) |
| `YGC`   | 100       | Young Generation의 가비지 수집 횟수      |
| `YGCT`  | 0.30      | Young Generation에서의 가비지 수집 시간(초) |
| `FGC`   | 10        | Full GC의 횟수                          |
| `FGCT`  | 0.05      | Full GC에서의 총 가비지 수집 시간(초)  |

간단하게 영GC가 한번 수행될 떄의 시간을 구하려면 YGCT / YGC 를 계산하면 된다.
하지만 CMS GC를 사용할 경우 Full GC 의 단계에 따라 수행되는 시간이 달라 평균값이 낮다고 그냥 무시해서는 안된다.
verbosegc 를 활용하는 것이 가장 확실하다.

### -gccapacity
| 열 이름 | 예시 응답 | 설명                                     |
|---------|-----------|------------------------------------------|
| `NGCMN` | 0         | Young Generation의 최소 크기 (MB)       |
| `NGCMX` | 1024      | Young Generation의 최대 크기 (MB)       |
| `NGC`   | 512       | Young Generation의 현재 크기 (MB)       |
| `S0C`   | 256       | Survivor Space 0의 크기 (MB)           |
| `S1C`   | 256       | Survivor Space 1의 크기 (MB)           |
| `EC`    | 512       | Eden Space의 크기 (MB)                  |
| `OC`    | 1024      | Old Generation의 크기 (MB)              |
| `MC`    | 2048      | Metaspace의 크기 (MB)                   |
| `CCS`   | 512       | Compressed Class Space의 크기 (MB)      |

## jstatd
jstat은 로컬 시스템에서만 모니터링 할 수 있다. 원격 모니터링을 하기위해서는 jstatd 를 사용해야한다.
원격이기 대문에 자바가 설치되어 있는 서버 내 디렉터리의 lib/security/java.policy 파일에 grant 명령어를 추가해줘야한다.

```text
grant {
    permission java.security.AllPermission;
};
```

```text
jstatd -J-Djava.security.policy=jstatd.policy -p 2020
```

이렇게 수행하면 원격으로 jstat 명령을 수행하여 결과를 확인할 수 있다. 원격지의 서버를 이 방식으로 사용하려면 해당 포트를 방화벽에서 열어주어야한다.

## verbose 를 통해 gc 로그 남기기
jstat 을 사용할 수 없는 상황에서 gc를 분석하기 위해서는 자바 수행시에 -verbosegc 라는 옵션을 넣어주면 된다.
java 22 에서는 명령어가 변경되었다.
```text
1. 가비지 수집에 대한 로그
java -Xlog:gc* MyApplication
java -Xlog:gc*:file=gc.log:time,level,tags MyApplication
gc.log 파일에 기록하고 시간, 로그 레벨, 태그를 포함하도록 설정

2. 클래스 로딩에 대한 정보
java -Xlog:class+load=info MyApplication

3. JNI 호출에 대한 정보
java -Xlog:jni* MyApplication
```

```text
[0.003s][info][gc] GC(1) Pause Young (Allocation Failure) 100M->20M(150M)
[0.034s][info][gc] GC(2) Pause Young (Allocation Failure) 120M->30M(150M)
[0.067s][info][gc] GC(3) Pause Full (Allocation Failure) 200M->100M(300M)
```

# GC 튜닝
GC 튜닝은 가장 마지막에 해야하는 작업이다. 다른 튜닝이 완료되었다면 다음의 환경에서 GC 튜닝을 한다.
- JVM 메모리 크기가 지정되지 않았다.
- Timeout 이 지속적으로 발생한다.

## GC 튜닝 절차
### GC 상황 모니터링
GC 수행에 소요된 시간이 0.1~0.3 초 라면 굳이 GC 튜닝할 필요는 없다.
하지만 1~3초, 10초를 넘어가는 상황이라면 진행해야한다.
1. YGC 와 TGCT의 값을 확인한다.YGCT / YGC 가 오래 걸린다면 튜닝이 필요하다.
2. FGCT와 FGC를 확인한다. FGCT / FGC 를 했을때 의 값이 오래 걸린다면 GC 튜닝이 필요하다.

다음의 조건에 부합하다면 GC 튜닝은 필요없다.
- minor GC 의 처리시간이 50ms 내외이다.
- minor GC 의 주기가 빈번하지 않다(10초 내외)
- Full GC 의 처리 시간이 빠르다(1초 내외)
- Full GC 의 주기가 빈번하지 않다 (10분에 1회)

절대 값은 아니고 서비스의 상황에 따라 달라질 수 있다.
만약 new 영역의 크기가 너무 작다면 마이너 GC 가 발생하는 빈도가 매우 높을 뿐만아니라 올드 영역으로 넘어가게 되어 full GC 횟수도 증가하게 된다.
따라서 각 영역을 얼마나 점유하고 어느 빈도수로 발생하는지도 확인해야한다.

### GC 방식 지정
운영중인 시스템 특성에 따라 적합한 GC 방식이 다르므로 해당 시스템에 최적인 방식을 찾아야한다.
운영중인 서버가 6대 정도 있다면 2대씩 각 옵션을 동일하게 지정하고 -verbosegc 옵션을 추가한 후 결과를 분석하는 방법을 추가한다.

### 메모리 크기 
- 메모리 크기가 크면
  - GC 발생 횟수는 감소한다.
  - GC 수행 시간은 길어진다.
- 메모리 크기가 작으면
  - GC 발생 횟수는 증가한다.
  - GC 수행 시간은 짧아진다.

### GC 튜닝 결과 분석
GC 옵션을 적용하고, -verbosegc 옵션을 지정한다음에 로그가 제대로 쌓이고 있는지 확인해야한다.
로그가 잘 쌓이고 있다면 하루, 혹은 이틀정도로 데이터가 축적된 후 결과를 확인해보자.
축적된 로그는 로컬PC로 옮긴 다음 HPJMeter 로 분석하는 것이 가장 수비다.
- Full GC 수행 시간
- Minor GC 수행 시간
- Full GC 수행 간격
- Minor GC 수행 간격
- 전체 Full GC 수행 시간
- 전체 Minor GC 수행 시간
- 전체 GC 수행 시간
- Full GC 수행 횟수
- Minor GC 수행 횟수