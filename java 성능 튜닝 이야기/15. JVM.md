# JVM 이란
JVM은 자바 어플리케이션을 실행하기 위해 필요한 가상 머신의 표준 사양을 정의한 개념이고,
이 사양을 기반으로 소프트웨어를 어떻게 설계하고 최적화 할지는 벤더마다 다르다.
hot spot jvm 은 오라클에서 제공하는 JVM 의 구현이고 다른 jvm 구현체로는 jRockIt, IBM JVM 도 JVM 의 구현체 이다. 

### jvm spec
https://docs.oracle.com/javase/specs/jvms/se11/html/

이렇게 JVM 구현체가 여러개로 만들어진 이유는 최적화 목표가 다르고, 플랫폼 호환성이 다르고, 고유한 추가 기능이 있을 수 있기 때문이다.
자바 바이트 코드를 실행하는 공통 목표를 갖고 있지만, 각기 다른 벤더가 자신의 방식으로 최적화하고 특화시킨 JVM 소프트웨어 들이다.

## hot spot jvm
1. javac 컴파일러릍 오해 바이트코드로 변환된 class 파일을 읽어서 실행한다.
2. hot spot 은 인터프리터 방식과 JIT 방식으로 컴파일을 한다.
3. 모든 변환된 바이트 코드는 인터프리터에의해 시작되고 해당 코드가 많이 사용되면 JIT 컴파일러에 의해 최적화된다.
4. hot spot JVM 는 각 메서드에 수행카운터(메서드 실행마다 증가), 백에지 카운터(메서드가 루프가 존재하는지 확인할 때 사용)를 두고 한계치에 도달하면 인터프리터가 JIT에 컴파일을 요청한다.
5. 인터프리터가 요청을 보내고 JIT 컴파일러가 컴파일하는 동안 카운터는 리셋되고 인터프리터는 계속 남은 요청을 실핸한다.
6. JIT 이 컴파일을 완료하면 바이트 코드는 기계어로 변환되어 코드캐시에 저장된다. 코드캐시에 저장된 기계어를 바로 CPU에서 실행한다.

- 인터프리터 : 바이트 코드를 한 줄씩 읽어서 JVM 내부의 데이터 구조로 바꾼다. 각 명령어가 해당하는 기계어로 변환해서 CPU에서 실행한다.
- JIT : 컴파일러가 바이트 코드를 기계어로 변환해 최적화 시킨다. 인터프리터를 거치지 않고 바로 CPU로 실행한다. 기계어 코드를 코드캐시라는 메모리에 저장해두고 실행한다.

JIT 으로 한번에 다 변환하는 것은 초기 시간도 많이 걸리고 메모리도 많이 사용된다. 반면 인터프리터는 실행시간이 빠르지만 JIT 으로 실행하는 것보다 느리다.
장기적으로 봤을때는 자주 사용되는 코드를 체크해 JIT 으로 변환해 사용하는 것이 효율적이다.

## JVM 시작 절차
1. java 명령줄에 있는 옵션 파싱 
   - JVM은 명령줄 옵션을 분석하여 힙 크기, 클래스 경로, 디버그 옵션 등을 설정합니다.
2. Java Heap 크기 및 JIT 컴파일러 설정
   - 힙 크기 설정은 명령줄 옵션에 따라 이루어지며, JIT 컴파일러(Just-In-Time Compiler)는 기본적으로 HotSpot JVM에서 사용됩니다.
3. 환경 변수 설정
   - JVM은 CLASSPATH, LD_LIBRARY_PATH 등의 환경 변수를 확인하여 클래스 파일과 네이티브 라이브러리 경로를 설정합니다.
4. Main 클래스 확인
   - JVM은 실행할 메인 클래스가 지정되었는지 확인합니다. 지정되지 않았다면 에러를 발생시킵니다.
5. JNI_CreateJavaVM 호출
   - JVM이 시작될 때, JNI_CreateJavaVM이 호출되어 HotSpot VM이 초기화됩니다. 이는 운영체제의 네이티브 스레드에서 수행됩니다.
6. HotSpot VM 초기화
   - HotSpot VM이 초기화된 후 JVM 런처는 지정된 메인 클래스를 로딩합니다. 런처는 java 명령으로 전달된 명령줄 인수들을 메인 메서드에 전달할 준비를 합니다.
7. Main 클래스의 main() 메서드 호출
   - JNI_CreateJavaVM을 통해 생성된 HotSpot VM은 메인 클래스의 main() 메서드를 호출합니다. 이때 명령줄에서 전달된 인수들이 main(String[] args)로 전달됩니다.

# 클래스 로딩 절차
1. JVM이 해당 클래스를 로드할 필요가 있다고 판단되면 수행된다. (객체 생성, 정적 메서드, 필드 호출)
2. 적당한 클래스 로더를 찾아서 결정한다.
   - 부모 클래스 로더 : 최상위 로더로 Bootstrap Class Loader 를 포함한다.
   - 확장 클래스 로더 : Java의 표준 확장 라이브러리를 로드한다.
   - 애플리케이션 클래스 로더 : CLASSPATH 에 정의된 클래스를 로드한다.
3. 클래스 탐색
   - 지정된 클래스로더는 CLASSPATH, JAR파일, 디렉토리 등을 검색하여 해당 클래스를 찾는다.
   - 클래스 파일이 발견되면, 해당 파일의 내용을 읽는다.
4. 클래스 바이트 코드 변환
   - 로드된 클래스 파일의 바이트 코드를 메모리에 적재한다. 이때 클래스의 메타데이터(필드, 메서드, 상수 등)도 메모리에 저장한다.
5. 링크
   - 검증 : 로드된 바이트코드가 자바 언어 규칙에 맞는지 확인하여 타입 안전성 확보
   - 준비 : static 변수에 기본 값을 할당, 이 단계에서 메모리가 할당된다.
   - 해결 : 클래스나 메서드에 대한 심볼릭 레퍼런스를 실제 메모리 레퍼런스로 변환한다.
6. 초기화
   - 클래스가 처음 사용되기 전에 초기화된다. static 블록, static 필드에 대한 값 할당이 이뤄진다.
7. 클래스 사용
   - 초기화가 완료된 후 해당 클래스를 사용할 수 있어진다. 이후부터는 이 클래스를 재사용하게 된다.

- 클래스로더는 자바가 실행되기 위해 필요한 모든 클래스 파일을 메모리에 올려두고 이를 실행가능한 상태로 만든다. 
- JVM은 바이트코드를 클래스 로드를 통해 불러온다.
- 런타임시에 클래스 로더를 통해서 클래스를 읽어들인다. 자바는 필요할 때만 클래스를 로드하는 방식을 사용한다. 
  - 클래스 참조, 서브클래스 생성, 정적 메서드 호출, reflection 사용시
- 이러한 동적 메커니즘 덕분에 자바는 메모리 사용을 효율적으로 관리할 수 있으며, 필요한 클래스만 메모리에 로드하여 프로그램의 성능을 향상시킬 수 있다.

## 로드타임 동적로딩
- 클래스가 로드되는 시점이 프로그램이 실행되기 전에 결정되는 경우를 말한다.
- 프로그램이 시작되기 전에 필요한 클래스를 미리 로드한다.
- 클래스 로더는 특정 클래스가 필요하다고 판단되면, 해당 클래스를 로드하여 메모리에 적재한다.
- 클래스 경로에 있는 클래스를 명시적으로 지정ㅎ하여 로드할 때 발생한다. import 

## 런타임 동적로딩
- 프로그램 실행 중에 필요한 클래스가 결정되고 로드되는 경우를 말한다.
- 필요할 때만 클래스를 로드하므로 메모리를 효율적으로 사용할 수 있따.
- 함수는 실행되기 전까지 어떤 클래스가 들어올지 모른다.(매개변수가 interface 일 경우) 따라서 로드타임에 로딩할 수 없다.
- 메서드가 실행되는 순간에 동적으로 로딩해야한다.