# 동기화는 이렇게 사용한다.
## 동일 객체 접근시, static 사용시
test : https://github.com/ohsuha/code_scratch/tree/master/code_scratch/src/main/java/test/synchronizedtest<br>
- 여러 스레드에서 접근할 수 있는 donate() 메소드에 대해 synchronized 를 설정해 한번에 한 스레드만 접근할 수 있게한다.
- 하지만 동기화는 성능을 떨어트리니 반드시 필요한 부분에만 동기화를 사용해야 한다.
- synchronized 는 각각의 객체에 대한 동기화를 하는 것이기 때문에, static 으로 선언한 변수에 접근할 때는 클래스의 변수이므로 동기화 되지 않는다. 따라서 메소드도 static 으로 지정해야한다.
- 하지만 항상 변하는 값에 대해서 static 으로 선언하여 사용하면 굉장히 위험하다.


## 동기화를 위해서 자바에서 제공하는 것들
java.util.concurrent 패키지에 포함되어 있는 주요한 네가지 개념
- Lock : 실행 중인 스레드를 간단한 방법으로 정지시켰다가 실행시킨다. 상호 참조로 인해 발생하는 데드락을 피할 수 있다.
- Executors : 스레드를 더 효율적으로 관리할 수 있는 클래스들을 제공한다. 스레드 풀도 제공하므로, 필요에 따라 유용하게 사용할 수 있다.
- Concurrent 콜렉션 : 콜렉션들의 Concurrent 클래스들을 제공한다.
- Atomic 변수 : 동기화가 되어 있는 변수를 제공한다. 이 변수를 사용하면, synchronized 식별자를 메서드에 지정할 필요 없이 사용할 수 있다.

## JVM 내에서 synchronization 은 어떻게 동작할까?
- 자바의 HotSpot VM 이 자바 모니터를 제공함으로써 스레드들이 상호 배제 프로토콜에 참요할 수 있도록 돕는다.
  - 상호 배제 프로토콜 : 자바 모니터는 lock 이나 unlock 중 하나이며 동일한 모니터에 진입한 여러 스레드들 중에서 한 시점에는 단 하나의 스레드만 모니터를 가질 수 있다.
  - 즉 모니터를 가진 스레드만 모니터에 의해서 보호되는 영역에 들어가서 작업을 할 수 있다.
  - 이 보호된 영역은 synchronized 로 감싸진 블록을 말한다. 모니터를 보유한 스레드가 작업을 마치면 다음 스레드에게 넘어간다.
- JDK 5 부터는 -XX:+BiasedLocking 옵션을 통해 biased Locking 이라는 기능을 제공한다.
  - 이 상태가되면 스레드는 많은 비용이 드는 인스트럭션 재배열 작업을 통해서 잠김과 풀림 작업을 수행한다.
  - 이 작업들은 진보된 적응 스피닝 기술로 처리량이 개선된다. 성능이 빨라진다.